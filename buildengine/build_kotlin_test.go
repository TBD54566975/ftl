package buildengine

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	"github.com/alecthomas/assert/v2"

	"github.com/TBD54566975/ftl/backend/schema"
	"github.com/TBD54566975/ftl/internal/log"
)

func TestGenerateBasicModule(t *testing.T) {
	sch := &schema.Schema{
		Modules: []*schema.Module{{Name: "test"}},
	}
	expected := `// Code generated by FTL. DO NOT EDIT.
package ftl.test

`
	assertExpectedSchema(t, sch, "test/Test.kt", expected)
}

func TestGenerateAllTypes(t *testing.T) {
	sch := &schema.Schema{
		Modules: []*schema.Module{
			{
				Name:     "test",
				Comments: []string{"Module comments"},
				Decls: []schema.Decl{
					&schema.Data{
						Name:           "ParamTestData",
						TypeParameters: []*schema.TypeParameter{{Name: "T"}},
						Fields: []*schema.Field{
							{Name: "t", Type: &schema.DataRef{Name: "T"}},
						},
					},
					&schema.Data{
						Name:     "TestResponse",
						Comments: []string{"Response comments"},
						Fields: []*schema.Field{
							{Name: "int", Type: &schema.Int{}},
							{Name: "float", Type: &schema.Float{}},
							{Name: "string", Type: &schema.String{}},
							{Name: "bytes", Type: &schema.Bytes{}},
							{Name: "bool", Type: &schema.Bool{}},
							{Name: "time", Type: &schema.Time{}},
							{Name: "optional", Type: &schema.Optional{
								Type: &schema.String{},
							}},
							{Name: "array", Type: &schema.Array{
								Element: &schema.String{},
							}},
							{Name: "nestedArray", Type: &schema.Array{
								Element: &schema.Array{Element: &schema.String{}}},
							},
							{Name: "dataRefArray", Type: &schema.Array{
								Element: &schema.DataRef{Name: "TestRequest", Module: "test"},
							}},
							{Name: "map", Type: &schema.Map{
								Key:   &schema.String{},
								Value: &schema.Int{},
							}},
							{Name: "nestedMap", Type: &schema.Map{
								Key:   &schema.String{},
								Value: &schema.Map{Key: &schema.String{}, Value: &schema.Int{}},
							}},
							{Name: "dataRef", Type: &schema.DataRef{Name: "TestRequest"}},
							{Name: "externalDataRef", Type: &schema.DataRef{Name: "TestRequest", Module: "other"}},
							{Name: "any", Type: &schema.Any{}},
							{Name: "parameterizedDataRef", Type: &schema.DataRef{
								Name:           "ParamTestData",
								TypeParameters: []schema.Type{&schema.DataRef{Name: "T"}},
							},
							},
							{Name: "withAlias", Type: &schema.String{}, Metadata: []schema.Metadata{&schema.MetadataAlias{Alias: "a"}}},
							{Name: "unit", Type: &schema.Unit{}},
						},
					},
				},
			},
		},
	}

	expected := `// Code generated by FTL. DO NOT EDIT.
/**
 * Module comments
 */
package ftl.test

import ftl.other.TestRequest
import ftl.test.TestRequest
import java.time.OffsetDateTime

data class ParamTestData<T>(
  val t: T,
)

/**
 * Response comments
 */
data class TestResponse(
  val int: Long,
  val float: Float,
  val string: String,
  val bytes: ByteArray,
  val bool: Boolean,
  val time: OffsetDateTime,
  val optional: String? = null,
  val array: List<String>,
  val nestedArray: List<List<String>>,
  val dataRefArray: List<TestRequest>,
  val map: Map<String, Long>,
  val nestedMap: Map<String, Map<String, Long>>,
  val dataRef: TestRequest,
  val externalDataRef: TestRequest,
  val any: Any,
  val parameterizedDataRef: ParamTestData<T>,
  val withAlias: String,
  val unit: Unit,
)

`
	assertExpectedSchema(t, sch, "test/Test.kt", expected)
}

func TestGenerateAllVerbs(t *testing.T) {
	sch := &schema.Schema{
		Modules: []*schema.Module{
			{
				Name:     "test",
				Comments: []string{"Module comments"},
				Decls: []schema.Decl{
					&schema.Data{
						Name: "Request",
						Fields: []*schema.Field{
							{Name: "data", Type: &schema.Int{}},
						},
					},
					&schema.Verb{
						Name:     "TestVerb",
						Comments: []string{"TestVerb comments"},
						Request:  &schema.DataRef{Name: "Request"},
						Response: &schema.DataRef{Name: "Empty", Module: "builtin"},
					},
				},
			},
		},
	}

	expected := `// Code generated by FTL. DO NOT EDIT.
/**
 * Module comments
 */
package ftl.test

import ftl.builtin.Empty
import xyz.block.ftl.Context
import xyz.block.ftl.Ignore
import xyz.block.ftl.Verb

data class Request(
  val data: Long,
)

/**
 * TestVerb comments
 */
@Verb
@Ignore
fun testVerb(context: Context, req: Request): Empty = throw
    NotImplementedError("Verb stubs should not be called directly, instead use context.call(::testVerb, ...)")
`
	assertExpectedSchema(t, sch, "test/Test.kt", expected)
}

func TestGenerateBuiltins(t *testing.T) {
	sch := &schema.Schema{
		Modules: []*schema.Module{
			schema.Builtins(),
		},
	}
	expected := `// Code generated by FTL. DO NOT EDIT.
/**
 * Built-in types for FTL.
 */
package ftl.builtin

/**
 * HTTP request structure used for HTTP ingress verbs.
 */
data class HttpRequest<Body>(
  val method: String,
  val path: String,
  val pathParameters: Map<String, String>,
  val query: Map<String, List<String>>,
  val headers: Map<String, List<String>>,
  val body: Body,
)

/**
 * HTTP response structure used for HTTP ingress verbs.
 */
data class HttpResponse<Body, Error>(
  val status: Long,
  val headers: Map<String, List<String>>,
  val body: Body? = null,
  val error: Error? = null,
)

class Empty
`
	assertExpectedSchema(t, sch, "builtin/Builtin.kt", expected)
}

func TestGenerateEmptyDataRefs(t *testing.T) {
	sch := &schema.Schema{
		Modules: []*schema.Module{
			{
				Name: "test",
				Decls: []schema.Decl{
					&schema.Data{Name: "EmptyRequest"},
					&schema.Data{Name: "EmptyResponse"},
					&schema.Verb{
						Name:     "EmptyVerb",
						Request:  &schema.DataRef{Name: "EmptyRequest"},
						Response: &schema.DataRef{Name: "EmptyResponse"},
					},
				},
			},
		},
	}

	expected := `// Code generated by FTL. DO NOT EDIT.
package ftl.test

import ftl.builtin.Empty
import xyz.block.ftl.Context
import xyz.block.ftl.Ignore
import xyz.block.ftl.Verb

@Verb
@Ignore
fun emptyVerb(context: Context, req: Empty): Empty = throw
    NotImplementedError("Verb stubs should not be called directly, instead use context.call(::emptyVerb, ...)")
`
	assertExpectedSchema(t, sch, "test/Test.kt", expected)
}

func assertExpectedSchema(t *testing.T, sch *schema.Schema, outputPath string, expectedContent string) {
	t.Helper()
	ctx := log.ContextWithLogger(context.Background(), log.Configure(os.Stderr, log.Config{}))
	module, err := LoadModule(ctx, "testdata/modules/echokotlin")
	assert.NoError(t, err)

	err = generateExternalModules(ctx, module, sch)
	assert.NoError(t, err)

	target := filepath.Join("testdata/modules/echokotlin", "target")
	output := filepath.Join(target, "generated-sources", "ftl", outputPath)

	fileContent, err := os.ReadFile(output)
	assert.NoError(t, err)
	assert.Equal(t, expectedContent, string(fileContent))

	err = os.RemoveAll(target)
	assert.NoError(t, err, "Error removing target directory")
}
