// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package sql

import (
	"context"
	"encoding/json"
	"time"

	"github.com/TBD54566975/ftl/backend/controller/sql/sqltypes"
	"github.com/TBD54566975/ftl/internal/model"
	"github.com/TBD54566975/ftl/internal/schema"
	"github.com/alecthomas/types/optional"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const acquireAsyncCall = `-- name: AcquireAsyncCall :one
WITH pending_calls AS (
  SELECT id
  FROM async_calls
  WHERE state = 'pending' AND scheduled_at <= (NOW() AT TIME ZONE 'utc')
  ORDER BY created_at
), async_call AS (
  SELECT id
  FROM pending_calls
  LIMIT 1
  FOR UPDATE SKIP LOCKED
)
UPDATE async_calls
SET state = 'executing'
WHERE id = (SELECT id FROM async_call)
RETURNING
  id AS async_call_id,
  (SELECT count(*) FROM pending_calls) AS queue_depth,
  origin,
  verb,
  catch_verb,
  request,
  scheduled_at,
  remaining_attempts,
  error,
  backoff,
  max_backoff,
  parent_request_key,
  trace_context,
  catching
`

type AcquireAsyncCallRow struct {
	AsyncCallID       int64
	QueueDepth        int64
	Origin            string
	Verb              schema.RefKey
	CatchVerb         optional.Option[schema.RefKey]
	Request           json.RawMessage
	ScheduledAt       time.Time
	RemainingAttempts int32
	Error             optional.Option[string]
	Backoff           sqltypes.Duration
	MaxBackoff        sqltypes.Duration
	ParentRequestKey  optional.Option[string]
	TraceContext      pqtype.NullRawMessage
	Catching          bool
}

// Reserve a pending async call for execution, returning the associated lease
// reservation key and accompanying metadata.
func (q *Queries) AcquireAsyncCall(ctx context.Context) (AcquireAsyncCallRow, error) {
	row := q.db.QueryRowContext(ctx, acquireAsyncCall)
	var i AcquireAsyncCallRow
	err := row.Scan(
		&i.AsyncCallID,
		&i.QueueDepth,
		&i.Origin,
		&i.Verb,
		&i.CatchVerb,
		&i.Request,
		&i.ScheduledAt,
		&i.RemainingAttempts,
		&i.Error,
		&i.Backoff,
		&i.MaxBackoff,
		&i.ParentRequestKey,
		&i.TraceContext,
		&i.Catching,
	)
	return i, err
}

const beginConsumingTopicEvent = `-- name: BeginConsumingTopicEvent :exec
WITH event AS (
    SELECT id, created_at, key, topic_id, caller, request_key, trace_context, payload
    FROM topic_events
    WHERE "key" = $2::topic_event_key
)
UPDATE topic_subscriptions
SET state = 'executing',
    cursor = (SELECT id FROM event)
WHERE key = $1::subscription_key
`

func (q *Queries) BeginConsumingTopicEvent(ctx context.Context, subscription model.SubscriptionKey, event model.TopicEventKey) error {
	_, err := q.db.ExecContext(ctx, beginConsumingTopicEvent, subscription, event)
	return err
}

const completeEventForSubscription = `-- name: CompleteEventForSubscription :exec
UPDATE topic_subscriptions
SET state = 'idle'
WHERE name = $1::TEXT
  AND module_name = $2::TEXT
`

func (q *Queries) CompleteEventForSubscription(ctx context.Context, name string, module string) error {
	_, err := q.db.ExecContext(ctx, completeEventForSubscription, name, module)
	return err
}

const createDeployment = `-- name: CreateDeployment :exec
INSERT INTO deployments (module_id, "schema", "key")
VALUES ((SELECT id FROM modules WHERE name = $1::TEXT LIMIT 1), $2::module_schema_pb, $3::deployment_key)
`

func (q *Queries) CreateDeployment(ctx context.Context, moduleName string, schema *schema.Module, key model.DeploymentKey) error {
	_, err := q.db.ExecContext(ctx, createDeployment, moduleName, schema, key)
	return err
}

const deleteSubscribers = `-- name: DeleteSubscribers :many
DELETE FROM topic_subscribers
WHERE deployment_key = $1::deployment_key
RETURNING topic_subscribers.key
`

func (q *Queries) DeleteSubscribers(ctx context.Context, deployment model.DeploymentKey) ([]model.SubscriberKey, error) {
	rows, err := q.db.QueryContext(ctx, deleteSubscribers, deployment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []model.SubscriberKey
	for rows.Next() {
		var key model.SubscriberKey
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteSubscriptions = `-- name: DeleteSubscriptions :many
DELETE FROM topic_subscriptions
WHERE deployment_key = $1::deployment_key
RETURNING topic_subscriptions.key
`

func (q *Queries) DeleteSubscriptions(ctx context.Context, deployment model.DeploymentKey) ([]model.SubscriptionKey, error) {
	rows, err := q.db.QueryContext(ctx, deleteSubscriptions, deployment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []model.SubscriptionKey
	for rows.Next() {
		var key model.SubscriptionKey
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const failAsyncCall = `-- name: FailAsyncCall :one
UPDATE async_calls
SET
  state = 'error'::async_call_state,
  error = $1::TEXT
WHERE id = $2
RETURNING true
`

func (q *Queries) FailAsyncCall(ctx context.Context, error string, iD int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, failAsyncCall, error, iD)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const failAsyncCallWithRetry = `-- name: FailAsyncCallWithRetry :one
WITH updated AS (
  UPDATE async_calls
  SET state = 'error'::async_call_state,
      error = $7::TEXT
  WHERE id = $8::BIGINT
  RETURNING id, created_at, verb, state, origin, scheduled_at, response, error, remaining_attempts, backoff, max_backoff, catch_verb, catching, parent_request_key, trace_context, request
)
INSERT INTO async_calls (
  verb,
  origin,
  request,
  catch_verb,
  remaining_attempts,
  backoff,
  max_backoff,
  scheduled_at,
  catching,
  error
)
SELECT
  updated.verb,
  updated.origin,
  updated.request,
  updated.catch_verb,
  $1,
  $2::interval,
  $3::interval,
  $4::TIMESTAMPTZ,
  $5::bool,
  $6
FROM updated
RETURNING true
`

type FailAsyncCallWithRetryParams struct {
	RemainingAttempts int32
	Backoff           sqltypes.Duration
	MaxBackoff        sqltypes.Duration
	ScheduledAt       time.Time
	Catching          bool
	OriginalError     optional.Option[string]
	Error             string
	ID                int64
}

func (q *Queries) FailAsyncCallWithRetry(ctx context.Context, arg FailAsyncCallWithRetryParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, failAsyncCallWithRetry,
		arg.RemainingAttempts,
		arg.Backoff,
		arg.MaxBackoff,
		arg.ScheduledAt,
		arg.Catching,
		arg.OriginalError,
		arg.Error,
		arg.ID,
	)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getActiveDeploymentSchemas = `-- name: GetActiveDeploymentSchemas :many
SELECT key, schema FROM deployments WHERE min_replicas > 0
`

type GetActiveDeploymentSchemasRow struct {
	Key    model.DeploymentKey
	Schema *schema.Module
}

func (q *Queries) GetActiveDeploymentSchemas(ctx context.Context) ([]GetActiveDeploymentSchemasRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveDeploymentSchemas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveDeploymentSchemasRow
	for rows.Next() {
		var i GetActiveDeploymentSchemasRow
		if err := rows.Scan(&i.Key, &i.Schema); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveDeployments = `-- name: GetActiveDeployments :many
SELECT d.id, d.created_at, d.module_id, d.key, d.schema, d.labels, d.min_replicas, d.last_activated_at, m.name AS module_name, m.language
FROM deployments d
  JOIN modules m ON d.module_id = m.id
WHERE min_replicas > 0
GROUP BY d.id, m.name, m.language
ORDER BY d.last_activated_at
`

type GetActiveDeploymentsRow struct {
	Deployment Deployment
	ModuleName string
	Language   string
}

func (q *Queries) GetActiveDeployments(ctx context.Context) ([]GetActiveDeploymentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveDeployments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveDeploymentsRow
	for rows.Next() {
		var i GetActiveDeploymentsRow
		if err := rows.Scan(
			&i.Deployment.ID,
			&i.Deployment.CreatedAt,
			&i.Deployment.ModuleID,
			&i.Deployment.Key,
			&i.Deployment.Schema,
			&i.Deployment.Labels,
			&i.Deployment.MinReplicas,
			&i.Deployment.LastActivatedAt,
			&i.ModuleName,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeployment = `-- name: GetDeployment :one
SELECT d.id, d.created_at, d.module_id, d.key, d.schema, d.labels, d.min_replicas, d.last_activated_at, m.language, m.name AS module_name, d.min_replicas
FROM deployments d
         INNER JOIN modules m ON m.id = d.module_id
WHERE d.key = $1::deployment_key
`

type GetDeploymentRow struct {
	Deployment  Deployment
	Language    string
	ModuleName  string
	MinReplicas int32
}

func (q *Queries) GetDeployment(ctx context.Context, key model.DeploymentKey) (GetDeploymentRow, error) {
	row := q.db.QueryRowContext(ctx, getDeployment, key)
	var i GetDeploymentRow
	err := row.Scan(
		&i.Deployment.ID,
		&i.Deployment.CreatedAt,
		&i.Deployment.ModuleID,
		&i.Deployment.Key,
		&i.Deployment.Schema,
		&i.Deployment.Labels,
		&i.Deployment.MinReplicas,
		&i.Deployment.LastActivatedAt,
		&i.Language,
		&i.ModuleName,
		&i.MinReplicas,
	)
	return i, err
}

const getDeploymentsByID = `-- name: GetDeploymentsByID :many
SELECT id, created_at, module_id, key, schema, labels, min_replicas, last_activated_at
FROM deployments
WHERE id = ANY ($1::BIGINT[])
`

func (q *Queries) GetDeploymentsByID(ctx context.Context, ids []int64) ([]Deployment, error) {
	rows, err := q.db.QueryContext(ctx, getDeploymentsByID, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Deployment
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.ModuleID,
			&i.Key,
			&i.Schema,
			&i.Labels,
			&i.MinReplicas,
			&i.LastActivatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeploymentsWithMinReplicas = `-- name: GetDeploymentsWithMinReplicas :many
SELECT d.id, d.created_at, d.module_id, d.key, d.schema, d.labels, d.min_replicas, d.last_activated_at, m.name AS module_name, m.language
FROM deployments d
  INNER JOIN modules m on d.module_id = m.id
WHERE min_replicas > 0
ORDER BY d.created_at,d.key
`

type GetDeploymentsWithMinReplicasRow struct {
	Deployment Deployment
	ModuleName string
	Language   string
}

func (q *Queries) GetDeploymentsWithMinReplicas(ctx context.Context) ([]GetDeploymentsWithMinReplicasRow, error) {
	rows, err := q.db.QueryContext(ctx, getDeploymentsWithMinReplicas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeploymentsWithMinReplicasRow
	for rows.Next() {
		var i GetDeploymentsWithMinReplicasRow
		if err := rows.Scan(
			&i.Deployment.ID,
			&i.Deployment.CreatedAt,
			&i.Deployment.ModuleID,
			&i.Deployment.Key,
			&i.Deployment.Schema,
			&i.Deployment.Labels,
			&i.Deployment.MinReplicas,
			&i.Deployment.LastActivatedAt,
			&i.ModuleName,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExistingDeploymentForModule = `-- name: GetExistingDeploymentForModule :one
SELECT d.id, created_at, module_id, key, schema, labels, min_replicas, last_activated_at, m.id, language, name
FROM deployments d
         INNER JOIN modules m on d.module_id = m.id
WHERE m.name = $1
  AND min_replicas > 0
LIMIT 1
`

type GetExistingDeploymentForModuleRow struct {
	ID              int64
	CreatedAt       time.Time
	ModuleID        int64
	Key             model.DeploymentKey
	Schema          *schema.Module
	Labels          json.RawMessage
	MinReplicas     int32
	LastActivatedAt time.Time
	ID_2            int64
	Language        string
	Name            string
}

func (q *Queries) GetExistingDeploymentForModule(ctx context.Context, name string) (GetExistingDeploymentForModuleRow, error) {
	row := q.db.QueryRowContext(ctx, getExistingDeploymentForModule, name)
	var i GetExistingDeploymentForModuleRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ModuleID,
		&i.Key,
		&i.Schema,
		&i.Labels,
		&i.MinReplicas,
		&i.LastActivatedAt,
		&i.ID_2,
		&i.Language,
		&i.Name,
	)
	return i, err
}

const getModulesByID = `-- name: GetModulesByID :many
SELECT id, language, name
FROM modules
WHERE id = ANY ($1::BIGINT[])
`

func (q *Queries) GetModulesByID(ctx context.Context, ids []int64) ([]Module, error) {
	rows, err := q.db.QueryContext(ctx, getModulesByID, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Module
	for rows.Next() {
		var i Module
		if err := rows.Scan(&i.ID, &i.Language, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextEventForSubscription = `-- name: GetNextEventForSubscription :one
WITH cursor AS (
    SELECT
        created_at,
        id
    FROM topic_events
    WHERE "key" = $3::topic_event_key
)
SELECT events."key" as event,
       events.payload,
       events.created_at,
       events.caller,
       events.request_key,
       events.trace_context,
       NOW() - events.created_at >= $1::interval AS ready
FROM topics
         LEFT JOIN topic_events as events ON events.topic_id = topics.id
WHERE topics.key = $2::topic_key
  AND (events.created_at, events.id) > (SELECT COALESCE(MAX(cursor.created_at), '1900-01-01'), COALESCE(MAX(cursor.id), 0) FROM cursor)
ORDER BY events.created_at, events.id
LIMIT 1
`

type GetNextEventForSubscriptionRow struct {
	Event        optional.Option[model.TopicEventKey]
	Payload      pqtype.NullRawMessage
	CreatedAt    sqltypes.OptionalTime
	Caller       optional.Option[string]
	RequestKey   optional.Option[string]
	TraceContext pqtype.NullRawMessage
	Ready        bool
}

func (q *Queries) GetNextEventForSubscription(ctx context.Context, consumptionDelay sqltypes.Duration, topic model.TopicKey, cursor optional.Option[model.TopicEventKey]) (GetNextEventForSubscriptionRow, error) {
	row := q.db.QueryRowContext(ctx, getNextEventForSubscription, consumptionDelay, topic, cursor)
	var i GetNextEventForSubscriptionRow
	err := row.Scan(
		&i.Event,
		&i.Payload,
		&i.CreatedAt,
		&i.Caller,
		&i.RequestKey,
		&i.TraceContext,
		&i.Ready,
	)
	return i, err
}

const getRandomSubscriber = `-- name: GetRandomSubscriber :one
SELECT
    subscribers.sink as sink,
    subscribers.retry_attempts as retry_attempts,
    subscribers.backoff as backoff,
    subscribers.max_backoff as max_backoff,
    subscribers.catch_verb as catch_verb,
    subscribers.deployment_key as deployment_key
FROM topic_subscribers as subscribers
         JOIN topic_subscriptions ON subscribers.topic_subscriptions_id = topic_subscriptions.id
WHERE topic_subscriptions.key = $1::subscription_key
ORDER BY RANDOM()
LIMIT 1
`

type GetRandomSubscriberRow struct {
	Sink          schema.RefKey
	RetryAttempts int32
	Backoff       sqltypes.Duration
	MaxBackoff    sqltypes.Duration
	CatchVerb     optional.Option[schema.RefKey]
	DeploymentKey model.DeploymentKey
}

func (q *Queries) GetRandomSubscriber(ctx context.Context, key model.SubscriptionKey) (GetRandomSubscriberRow, error) {
	row := q.db.QueryRowContext(ctx, getRandomSubscriber, key)
	var i GetRandomSubscriberRow
	err := row.Scan(
		&i.Sink,
		&i.RetryAttempts,
		&i.Backoff,
		&i.MaxBackoff,
		&i.CatchVerb,
		&i.DeploymentKey,
	)
	return i, err
}

const getSchemaForDeployment = `-- name: GetSchemaForDeployment :one
SELECT schema FROM deployments WHERE key = $1::deployment_key
`

func (q *Queries) GetSchemaForDeployment(ctx context.Context, key model.DeploymentKey) (*schema.Module, error) {
	row := q.db.QueryRowContext(ctx, getSchemaForDeployment, key)
	var schema *schema.Module
	err := row.Scan(&schema)
	return schema, err
}

const getSubscription = `-- name: GetSubscription :one
SELECT id, key, created_at, topic_id, name, cursor, state, deployment_key, module_name
FROM topic_subscriptions
WHERE name = $1::TEXT
  AND module_name = $2::TEXT
`

func (q *Queries) GetSubscription(ctx context.Context, column1 string, column2 string) (TopicSubscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscription, column1, column2)
	var i TopicSubscription
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.CreatedAt,
		&i.TopicID,
		&i.Name,
		&i.Cursor,
		&i.State,
		&i.DeploymentKey,
		&i.ModuleName,
	)
	return i, err
}

const getSubscriptionsNeedingUpdate = `-- name: GetSubscriptionsNeedingUpdate :many
SELECT
    subs.key::subscription_key as key,
    curser.key as cursor,
    topics.key::topic_key as topic,
    subs.name,
    deployment_key as deployment_key,
    curser.request_key as request_key
FROM topic_subscriptions subs
         LEFT JOIN topics ON subs.topic_id = topics.id
         LEFT JOIN topic_events curser ON subs.cursor = curser.id
WHERE subs.cursor IS DISTINCT FROM topics.head
  AND subs.state = 'idle'
ORDER BY curser.created_at
LIMIT 3
    FOR UPDATE OF subs SKIP LOCKED
`

type GetSubscriptionsNeedingUpdateRow struct {
	Key           model.SubscriptionKey
	Cursor        optional.Option[model.TopicEventKey]
	Topic         model.TopicKey
	Name          string
	DeploymentKey model.DeploymentKey
	RequestKey    optional.Option[string]
}

// Results may not be ready to be scheduled yet due to event consumption delay
// Sorting ensures that brand new events (that may not be ready for consumption)
// don't prevent older events from being consumed
// We also make sure that the subscription belongs to a deployment that has at least one runner
func (q *Queries) GetSubscriptionsNeedingUpdate(ctx context.Context) ([]GetSubscriptionsNeedingUpdateRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubscriptionsNeedingUpdate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubscriptionsNeedingUpdateRow
	for rows.Next() {
		var i GetSubscriptionsNeedingUpdateRow
		if err := rows.Scan(
			&i.Key,
			&i.Cursor,
			&i.Topic,
			&i.Name,
			&i.DeploymentKey,
			&i.RequestKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopic = `-- name: GetTopic :one
SELECT id, key, created_at, name, type, head, module_name
FROM topics
WHERE id = $1::BIGINT
`

func (q *Queries) GetTopic(ctx context.Context, dollar_1 int64) (Topic, error) {
	row := q.db.QueryRowContext(ctx, getTopic, dollar_1)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.CreatedAt,
		&i.Name,
		&i.Type,
		&i.Head,
		&i.ModuleName,
	)
	return i, err
}

const getTopicEvent = `-- name: GetTopicEvent :one
SELECT id, created_at, key, topic_id, caller, request_key, trace_context, payload
FROM topic_events
WHERE id = $1::BIGINT
`

func (q *Queries) GetTopicEvent(ctx context.Context, dollar_1 int64) (TopicEvent, error) {
	row := q.db.QueryRowContext(ctx, getTopicEvent, dollar_1)
	var i TopicEvent
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Key,
		&i.TopicID,
		&i.Caller,
		&i.RequestKey,
		&i.TraceContext,
		&i.Payload,
	)
	return i, err
}

const getZombieAsyncCalls = `-- name: GetZombieAsyncCalls :many
SELECT id, created_at, verb, state, origin, scheduled_at, response, error, remaining_attempts, backoff, max_backoff, catch_verb, catching, parent_request_key, trace_context, request
FROM async_calls
WHERE state = 'executing'
ORDER BY created_at ASC
LIMIT $1::INT
`

func (q *Queries) GetZombieAsyncCalls(ctx context.Context, limit int32) ([]AsyncCall, error) {
	rows, err := q.db.QueryContext(ctx, getZombieAsyncCalls, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AsyncCall
	for rows.Next() {
		var i AsyncCall
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Verb,
			&i.State,
			&i.Origin,
			&i.ScheduledAt,
			&i.Response,
			&i.Error,
			&i.RemainingAttempts,
			&i.Backoff,
			&i.MaxBackoff,
			&i.CatchVerb,
			&i.Catching,
			&i.ParentRequestKey,
			&i.TraceContext,
			&i.Request,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSubscriber = `-- name: InsertSubscriber :exec
INSERT INTO topic_subscribers (
    key,
    topic_subscriptions_id,
    deployment_key,
    sink,
    retry_attempts,
    backoff,
    max_backoff,
    catch_verb
)
VALUES (
           $1::subscriber_key,
           (
               SELECT topic_subscriptions.id as id
               FROM topic_subscriptions
               WHERE module_name = $2::TEXT
                 AND topic_subscriptions.name = $3::TEXT
           ),
           $4::deployment_key,
           $5,
           $6,
           $7::interval,
           $8::interval,
           $9
       )
`

type InsertSubscriberParams struct {
	Key              model.SubscriberKey
	Module           string
	SubscriptionName string
	Deployment       model.DeploymentKey
	Sink             schema.RefKey
	RetryAttempts    int32
	Backoff          sqltypes.Duration
	MaxBackoff       sqltypes.Duration
	CatchVerb        optional.Option[schema.RefKey]
}

func (q *Queries) InsertSubscriber(ctx context.Context, arg InsertSubscriberParams) error {
	_, err := q.db.ExecContext(ctx, insertSubscriber,
		arg.Key,
		arg.Module,
		arg.SubscriptionName,
		arg.Deployment,
		arg.Sink,
		arg.RetryAttempts,
		arg.Backoff,
		arg.MaxBackoff,
		arg.CatchVerb,
	)
	return err
}

const loadAsyncCall = `-- name: LoadAsyncCall :one
SELECT id, created_at, verb, state, origin, scheduled_at, response, error, remaining_attempts, backoff, max_backoff, catch_verb, catching, parent_request_key, trace_context, request
FROM async_calls
WHERE id = $1
`

func (q *Queries) LoadAsyncCall(ctx context.Context, id int64) (AsyncCall, error) {
	row := q.db.QueryRowContext(ctx, loadAsyncCall, id)
	var i AsyncCall
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Verb,
		&i.State,
		&i.Origin,
		&i.ScheduledAt,
		&i.Response,
		&i.Error,
		&i.RemainingAttempts,
		&i.Backoff,
		&i.MaxBackoff,
		&i.CatchVerb,
		&i.Catching,
		&i.ParentRequestKey,
		&i.TraceContext,
		&i.Request,
	)
	return i, err
}

const publishEventForTopic = `-- name: PublishEventForTopic :exec
INSERT INTO topic_events (
    "key",
    topic_id,
    caller,
    payload,
    request_key,
    trace_context
)
VALUES (
           $1::topic_event_key,
           (
               SELECT topics.id
               FROM topics
               WHERE module_name = $2::TEXT
                 AND topics.name = $3::TEXT
           ),
           $4::TEXT,
           $5,
           $6::TEXT,
           $7::jsonb
       )
`

type PublishEventForTopicParams struct {
	Key          model.TopicEventKey
	Module       string
	Topic        string
	Caller       string
	Payload      json.RawMessage
	RequestKey   string
	TraceContext json.RawMessage
}

func (q *Queries) PublishEventForTopic(ctx context.Context, arg PublishEventForTopicParams) error {
	_, err := q.db.ExecContext(ctx, publishEventForTopic,
		arg.Key,
		arg.Module,
		arg.Topic,
		arg.Caller,
		arg.Payload,
		arg.RequestKey,
		arg.TraceContext,
	)
	return err
}

const setDeploymentDesiredReplicas = `-- name: SetDeploymentDesiredReplicas :exec
UPDATE deployments
SET min_replicas = $2, last_activated_at = CASE WHEN min_replicas = 0 THEN (NOW() AT TIME ZONE 'utc') ELSE  last_activated_at END
WHERE key = $1::deployment_key
RETURNING 1
`

func (q *Queries) SetDeploymentDesiredReplicas(ctx context.Context, key model.DeploymentKey, minReplicas int32) error {
	_, err := q.db.ExecContext(ctx, setDeploymentDesiredReplicas, key, minReplicas)
	return err
}

const setSubscriptionCursor = `-- name: SetSubscriptionCursor :exec
WITH event AS (
    SELECT id, created_at, key, topic_id, payload
    FROM topic_events
    WHERE "key" = $2::topic_event_key
)
UPDATE topic_subscriptions
SET cursor = (SELECT id FROM event)
WHERE key = $1::subscription_key
`

func (q *Queries) SetSubscriptionCursor(ctx context.Context, column1 model.SubscriptionKey, column2 model.TopicEventKey) error {
	_, err := q.db.ExecContext(ctx, setSubscriptionCursor, column1, column2)
	return err
}

const succeedAsyncCall = `-- name: SucceedAsyncCall :one
UPDATE async_calls
SET
  state = 'success'::async_call_state,
  response = $1,
  error = null
WHERE id = $2
RETURNING true
`

func (q *Queries) SucceedAsyncCall(ctx context.Context, response interface{}, iD int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, succeedAsyncCall, response, iD)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const updateDeploymentSchema = `-- name: UpdateDeploymentSchema :exec
UPDATE deployments
SET schema = $1::module_schema_pb
WHERE key = $2::deployment_key
RETURNING 1
`

// Note that this can result in a race condition if the deployment is being updated by another process. This will go
// away once we ditch the DB.
func (q *Queries) UpdateDeploymentSchema(ctx context.Context, schema *schema.Module, key model.DeploymentKey) error {
	_, err := q.db.ExecContext(ctx, updateDeploymentSchema, schema, key)
	return err
}

const upsertModule = `-- name: UpsertModule :one
INSERT INTO modules (language, name)
VALUES ($1, $2)
ON CONFLICT (name) DO UPDATE SET language = $1
RETURNING id
`

func (q *Queries) UpsertModule(ctx context.Context, language string, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertModule, language, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertSubscription = `-- name: UpsertSubscription :one
INSERT INTO topic_subscriptions (
    key,
    topic_id,
    module_name,
    deployment_key,
    name)
VALUES (
           $1::subscription_key,
           (
               SELECT topics.id as id
               FROM topics
               WHERE module_name = $2::TEXT
                 AND topics.name = $3::TEXT
           ),
           $4::TEXT,
           $5::deployment_key,
           $6::TEXT
       )
ON CONFLICT (name, module_name) DO
    UPDATE SET
               topic_id = excluded.topic_id,
               deployment_key = $5::deployment_key
RETURNING
    id,
    CASE
        WHEN xmax = 0 THEN true
        ELSE false
        END AS inserted
`

type UpsertSubscriptionParams struct {
	Key         model.SubscriptionKey
	TopicModule string
	TopicName   string
	Module      string
	Deployment  model.DeploymentKey
	Name        string
}

type UpsertSubscriptionRow struct {
	ID       int64
	Inserted bool
}

func (q *Queries) UpsertSubscription(ctx context.Context, arg UpsertSubscriptionParams) (UpsertSubscriptionRow, error) {
	row := q.db.QueryRowContext(ctx, upsertSubscription,
		arg.Key,
		arg.TopicModule,
		arg.TopicName,
		arg.Module,
		arg.Deployment,
		arg.Name,
	)
	var i UpsertSubscriptionRow
	err := row.Scan(&i.ID, &i.Inserted)
	return i, err
}

const upsertTopic = `-- name: UpsertTopic :exec
INSERT INTO topics (key, module_name, name, type)
VALUES (
           $1::topic_key,
           $2::TEXT,
           $3::TEXT,
           $4::TEXT
       )
ON CONFLICT (name, module_name) DO
    UPDATE SET
    type = $4::TEXT
RETURNING id
`

type UpsertTopicParams struct {
	Topic     model.TopicKey
	Module    string
	Name      string
	EventType string
}

func (q *Queries) UpsertTopic(ctx context.Context, arg UpsertTopicParams) error {
	_, err := q.db.ExecContext(ctx, upsertTopic,
		arg.Topic,
		arg.Module,
		arg.Name,
		arg.EventType,
	)
	return err
}
