// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package sql

import (
	"context"
	"time"

	"github.com/TBD54566975/ftl/internal/model"
)

const createCronJob = `-- name: CreateCronJob :exec
SELECT create_cron_job(
  $1::cron_job_key,
  $2::deployment_key,
  $3::TEXT,
  $4::TEXT,
  $5::TEXT,
  $6::TIMESTAMPTZ,
  $7::TIMESTAMPTZ)
`

type CreateCronJobParams struct {
	Key           model.CronJobKey
	DeploymentKey model.DeploymentKey
	ModuleName    string
	Verb          string
	Schedule      string
	StartTime     time.Time
	NextExecution time.Time
}

func (q *Queries) CreateCronJob(ctx context.Context, arg CreateCronJobParams) error {
	_, err := q.db.Exec(ctx, createCronJob,
		arg.Key,
		arg.DeploymentKey,
		arg.ModuleName,
		arg.Verb,
		arg.Schedule,
		arg.StartTime,
		arg.NextExecution,
	)
	return err
}

const endCronJob = `-- name: EndCronJob :one
WITH j AS (
UPDATE cron_jobs
  SET state = 'idle',
    next_execution = $1::TIMESTAMPTZ
  WHERE key = $2::cron_job_key
    AND state = 'executing'
    AND start_time = $3::TIMESTAMPTZ
  RETURNING id, key, deployment_id, verb, schedule, start_time, next_execution, state, module_name
)
SELECT j.key as key, d.key as deployment_key, j.module_name as module, j.verb, j.schedule, j.start_time, j.next_execution, j.state
  FROM j
  INNER JOIN deployments d on j.deployment_id = d.id
  LIMIT 1
`

type EndCronJobRow struct {
	Key           model.CronJobKey
	DeploymentKey model.DeploymentKey
	Module        string
	Verb          string
	Schedule      string
	StartTime     time.Time
	NextExecution time.Time
	State         model.CronJobState
}

func (q *Queries) EndCronJob(ctx context.Context, nextExecution time.Time, key model.CronJobKey, startTime time.Time) (EndCronJobRow, error) {
	row := q.db.QueryRow(ctx, endCronJob, nextExecution, key, startTime)
	var i EndCronJobRow
	err := row.Scan(
		&i.Key,
		&i.DeploymentKey,
		&i.Module,
		&i.Verb,
		&i.Schedule,
		&i.StartTime,
		&i.NextExecution,
		&i.State,
	)
	return i, err
}

const getCronJobs = `-- name: GetCronJobs :many
SELECT j.key as key, d.key as deployment_key, j.module_name as module, j.verb, j.schedule, j.start_time, j.next_execution, j.state
FROM cron_jobs j
  INNER JOIN deployments d on j.deployment_id = d.id
WHERE d.min_replicas > 0
`

type GetCronJobsRow struct {
	Key           model.CronJobKey
	DeploymentKey model.DeploymentKey
	Module        string
	Verb          string
	Schedule      string
	StartTime     time.Time
	NextExecution time.Time
	State         model.CronJobState
}

func (q *Queries) GetCronJobs(ctx context.Context) ([]GetCronJobsRow, error) {
	rows, err := q.db.Query(ctx, getCronJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCronJobsRow
	for rows.Next() {
		var i GetCronJobsRow
		if err := rows.Scan(
			&i.Key,
			&i.DeploymentKey,
			&i.Module,
			&i.Verb,
			&i.Schedule,
			&i.StartTime,
			&i.NextExecution,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStaleCronJobs = `-- name: GetStaleCronJobs :many
SELECT j.key as key, d.key as deployment_key, j.module_name as module, j.verb, j.schedule, j.start_time, j.next_execution, j.state
FROM cron_jobs j
  INNER JOIN deployments d on j.deployment_id = d.id
WHERE state = 'executing'
  AND start_time < (NOW() AT TIME ZONE 'utc') - $1::INTERVAL
`

type GetStaleCronJobsRow struct {
	Key           model.CronJobKey
	DeploymentKey model.DeploymentKey
	Module        string
	Verb          string
	Schedule      string
	StartTime     time.Time
	NextExecution time.Time
	State         model.CronJobState
}

func (q *Queries) GetStaleCronJobs(ctx context.Context, dollar_1 time.Duration) ([]GetStaleCronJobsRow, error) {
	rows, err := q.db.Query(ctx, getStaleCronJobs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStaleCronJobsRow
	for rows.Next() {
		var i GetStaleCronJobsRow
		if err := rows.Scan(
			&i.Key,
			&i.DeploymentKey,
			&i.Module,
			&i.Verb,
			&i.Schedule,
			&i.StartTime,
			&i.NextExecution,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startCronJobs = `-- name: StartCronJobs :many
WITH updates AS (
  UPDATE cron_jobs
  SET state = 'executing',
    start_time = (NOW() AT TIME ZONE 'utc')::TIMESTAMPTZ
  WHERE key = ANY ($1)
    AND state = 'idle'
    AND start_time < next_execution
    AND (next_execution AT TIME ZONE 'utc') < (NOW() AT TIME ZONE 'utc')::TIMESTAMPTZ
  RETURNING id, key, state, start_time, next_execution)
SELECT j.key as key, d.key as deployment_key, j.module_name as module, j.verb, j.schedule,
  COALESCE(u.start_time, j.start_time) as start_time,
  COALESCE(u.next_execution, j.next_execution) as next_execution,
  COALESCE(u.state, j.state) as state,
  d.min_replicas > 0 as has_min_replicas,
  CASE WHEN u.key IS NULL THEN FALSE ELSE TRUE END as updated
FROM cron_jobs j
  INNER JOIN deployments d on j.deployment_id = d.id
  LEFT JOIN updates u on j.id = u.id
WHERE j.key = ANY ($1)
`

type StartCronJobsRow struct {
	Key            model.CronJobKey
	DeploymentKey  model.DeploymentKey
	Module         string
	Verb           string
	Schedule       string
	StartTime      time.Time
	NextExecution  time.Time
	State          model.CronJobState
	HasMinReplicas bool
	Updated        bool
}

func (q *Queries) StartCronJobs(ctx context.Context, keys []string) ([]StartCronJobsRow, error) {
	rows, err := q.db.Query(ctx, startCronJobs, keys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StartCronJobsRow
	for rows.Next() {
		var i StartCronJobsRow
		if err := rows.Scan(
			&i.Key,
			&i.DeploymentKey,
			&i.Module,
			&i.Verb,
			&i.Schedule,
			&i.StartTime,
			&i.NextExecution,
			&i.State,
			&i.HasMinReplicas,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
