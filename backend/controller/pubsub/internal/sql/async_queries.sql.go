// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: async_queries.sql

package sql

import (
	"context"
	"encoding/json"
	"time"

	"github.com/TBD54566975/ftl/backend/controller/sql/sqltypes"
	"github.com/TBD54566975/ftl/internal/schema"
	"github.com/alecthomas/types/optional"
	"github.com/sqlc-dev/pqtype"
)

const acquireAsyncCall = `-- name: AcquireAsyncCall :one
WITH pending_calls AS (
  SELECT id
  FROM async_calls
  WHERE state = 'pending' AND scheduled_at <= (NOW() AT TIME ZONE 'utc')
  ORDER BY created_at
), async_call AS (
  SELECT id
  FROM pending_calls
  LIMIT 1
  FOR UPDATE SKIP LOCKED
)
UPDATE async_calls
SET state = 'executing'
WHERE id = (SELECT id FROM async_call)
RETURNING
  id AS async_call_id,
  (SELECT count(*) FROM pending_calls) AS queue_depth,
  origin,
  verb,
  catch_verb,
  request,
  scheduled_at,
  remaining_attempts,
  error,
  backoff,
  max_backoff,
  parent_request_key,
  trace_context,
  catching
`

type AcquireAsyncCallRow struct {
	AsyncCallID       int64
	QueueDepth        int64
	Origin            string
	Verb              schema.RefKey
	CatchVerb         optional.Option[schema.RefKey]
	Request           json.RawMessage
	ScheduledAt       time.Time
	RemainingAttempts int32
	Error             optional.Option[string]
	Backoff           sqltypes.Duration
	MaxBackoff        sqltypes.Duration
	ParentRequestKey  optional.Option[string]
	TraceContext      pqtype.NullRawMessage
	Catching          bool
}

// Reserve a pending async call for execution, returning the associated lease
// reservation key and accompanying metadata.
func (q *Queries) AcquireAsyncCall(ctx context.Context) (AcquireAsyncCallRow, error) {
	row := q.db.QueryRowContext(ctx, acquireAsyncCall)
	var i AcquireAsyncCallRow
	err := row.Scan(
		&i.AsyncCallID,
		&i.QueueDepth,
		&i.Origin,
		&i.Verb,
		&i.CatchVerb,
		&i.Request,
		&i.ScheduledAt,
		&i.RemainingAttempts,
		&i.Error,
		&i.Backoff,
		&i.MaxBackoff,
		&i.ParentRequestKey,
		&i.TraceContext,
		&i.Catching,
	)
	return i, err
}

const asyncCallQueueDepth = `-- name: AsyncCallQueueDepth :one
SELECT count(*)
FROM async_calls
WHERE state = 'pending' AND scheduled_at <= (NOW() AT TIME ZONE 'utc')
`

func (q *Queries) AsyncCallQueueDepth(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, asyncCallQueueDepth)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAsyncCall = `-- name: CreateAsyncCall :one
INSERT INTO async_calls (
  scheduled_at,
  verb,
  origin,
  request,
  remaining_attempts,
  backoff,
  max_backoff,
  catch_verb,
  parent_request_key,
  trace_context
)
VALUES (
  $1::TIMESTAMPTZ,
  $2,
  $3,
  $4,
  $5,
  $6::interval,
  $7::interval,
  $8,
  $9,
  $10::jsonb
)
RETURNING id
`

type CreateAsyncCallParams struct {
	ScheduledAt       time.Time
	Verb              schema.RefKey
	Origin            string
	Request           json.RawMessage
	RemainingAttempts int32
	Backoff           sqltypes.Duration
	MaxBackoff        sqltypes.Duration
	CatchVerb         optional.Option[schema.RefKey]
	ParentRequestKey  optional.Option[string]
	TraceContext      json.RawMessage
}

func (q *Queries) CreateAsyncCall(ctx context.Context, arg CreateAsyncCallParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createAsyncCall,
		arg.ScheduledAt,
		arg.Verb,
		arg.Origin,
		arg.Request,
		arg.RemainingAttempts,
		arg.Backoff,
		arg.MaxBackoff,
		arg.CatchVerb,
		arg.ParentRequestKey,
		arg.TraceContext,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const failAsyncCall = `-- name: FailAsyncCall :one
UPDATE async_calls
SET
  state = 'error'::async_call_state,
  error = $1::TEXT
WHERE id = $2
RETURNING true
`

func (q *Queries) FailAsyncCall(ctx context.Context, error string, iD int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, failAsyncCall, error, iD)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const failAsyncCallWithRetry = `-- name: FailAsyncCallWithRetry :one
WITH updated AS (
  UPDATE async_calls
  SET state = 'error'::async_call_state,
      error = $7::TEXT
  WHERE id = $8::BIGINT
  RETURNING id, created_at, verb, state, origin, scheduled_at, response, error, remaining_attempts, backoff, max_backoff, catch_verb, catching, parent_request_key, trace_context, request
)
INSERT INTO async_calls (
  verb,
  origin,
  request,
  catch_verb,
  remaining_attempts,
  backoff,
  max_backoff,
  scheduled_at,
  catching,
  error
)
SELECT
  updated.verb,
  updated.origin,
  updated.request,
  updated.catch_verb,
  $1,
  $2::interval,
  $3::interval,
  $4::TIMESTAMPTZ,
  $5::bool,
  $6
FROM updated
RETURNING true
`

type FailAsyncCallWithRetryParams struct {
	RemainingAttempts int32
	Backoff           sqltypes.Duration
	MaxBackoff        sqltypes.Duration
	ScheduledAt       time.Time
	Catching          bool
	OriginalError     optional.Option[string]
	Error             string
	ID                int64
}

func (q *Queries) FailAsyncCallWithRetry(ctx context.Context, arg FailAsyncCallWithRetryParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, failAsyncCallWithRetry,
		arg.RemainingAttempts,
		arg.Backoff,
		arg.MaxBackoff,
		arg.ScheduledAt,
		arg.Catching,
		arg.OriginalError,
		arg.Error,
		arg.ID,
	)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getZombieAsyncCalls = `-- name: GetZombieAsyncCalls :many
SELECT id, created_at, verb, state, origin, scheduled_at, response, error, remaining_attempts, backoff, max_backoff, catch_verb, catching, parent_request_key, trace_context, request
FROM async_calls
WHERE state = 'executing'
ORDER BY created_at ASC
LIMIT $1::INT
`

func (q *Queries) GetZombieAsyncCalls(ctx context.Context, limit int32) ([]AsyncCall, error) {
	rows, err := q.db.QueryContext(ctx, getZombieAsyncCalls, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AsyncCall
	for rows.Next() {
		var i AsyncCall
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Verb,
			&i.State,
			&i.Origin,
			&i.ScheduledAt,
			&i.Response,
			&i.Error,
			&i.RemainingAttempts,
			&i.Backoff,
			&i.MaxBackoff,
			&i.CatchVerb,
			&i.Catching,
			&i.ParentRequestKey,
			&i.TraceContext,
			&i.Request,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadAsyncCall = `-- name: LoadAsyncCall :one
SELECT id, created_at, verb, state, origin, scheduled_at, response, error, remaining_attempts, backoff, max_backoff, catch_verb, catching, parent_request_key, trace_context, request
FROM async_calls
WHERE id = $1
`

func (q *Queries) LoadAsyncCall(ctx context.Context, id int64) (AsyncCall, error) {
	row := q.db.QueryRowContext(ctx, loadAsyncCall, id)
	var i AsyncCall
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Verb,
		&i.State,
		&i.Origin,
		&i.ScheduledAt,
		&i.Response,
		&i.Error,
		&i.RemainingAttempts,
		&i.Backoff,
		&i.MaxBackoff,
		&i.CatchVerb,
		&i.Catching,
		&i.ParentRequestKey,
		&i.TraceContext,
		&i.Request,
	)
	return i, err
}

const succeedAsyncCall = `-- name: SucceedAsyncCall :one
UPDATE async_calls
SET
  state = 'success'::async_call_state,
  response = $1,
  error = null
WHERE id = $2
RETURNING true
`

func (q *Queries) SucceedAsyncCall(ctx context.Context, response interface{}, iD int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, succeedAsyncCall, response, iD)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}
