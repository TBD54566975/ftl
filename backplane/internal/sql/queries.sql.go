// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: queries.sql

package sql

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const associateArtefactWithDeployment = `-- name: AssociateArtefactWithDeployment :exec
INSERT INTO deployment_artefacts (deployment_id, artefact_id, executable, path)
VALUES ((SELECT id FROM deployments WHERE key = $1), $2, $3, $4)
`

type AssociateArtefactWithDeploymentParams struct {
	Key        uuid.UUID
	ArtefactID int64
	Executable bool
	Path       string
}

func (q *Queries) AssociateArtefactWithDeployment(ctx context.Context, arg AssociateArtefactWithDeploymentParams) error {
	_, err := q.db.Exec(ctx, associateArtefactWithDeployment,
		arg.Key,
		arg.ArtefactID,
		arg.Executable,
		arg.Path,
	)
	return err
}

const createArtefact = `-- name: CreateArtefact :one
INSERT INTO artefacts (digest, content)
VALUES ($1, $2)
RETURNING id
`

type CreateArtefactParams struct {
	Digest  []byte
	Content []byte
}

// Create a new artefact and return the artefact ID.
func (q *Queries) CreateArtefact(ctx context.Context, arg CreateArtefactParams) (int64, error) {
	row := q.db.QueryRow(ctx, createArtefact, arg.Digest, arg.Content)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createDeployment = `-- name: CreateDeployment :one
INSERT INTO deployments (module_id, "schema")
VALUES ((SELECT id FROM modules WHERE name = $1::TEXT LIMIT 1), $2::BYTEA)
RETURNING key
`

type CreateDeploymentParams struct {
	ModuleName string
	Schema     []byte
}

func (q *Queries) CreateDeployment(ctx context.Context, arg CreateDeploymentParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createDeployment, arg.ModuleName, arg.Schema)
	var key uuid.UUID
	err := row.Scan(&key)
	return key, err
}

const createModule = `-- name: CreateModule :one
INSERT INTO modules (language, name) VALUES ($1, $2)
ON CONFLICT (name) DO UPDATE SET language = $1
RETURNING id
`

type CreateModuleParams struct {
	Language string
	Name     string
}

func (q *Queries) CreateModule(ctx context.Context, arg CreateModuleParams) (int64, error) {
	row := q.db.QueryRow(ctx, createModule, arg.Language, arg.Name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getArtefactDigests = `-- name: GetArtefactDigests :many
SELECT id, digest FROM artefacts WHERE digest = ANY($1::bytea[])
`

type GetArtefactDigestsRow struct {
	ID     int64
	Digest []byte
}

// Return the digests that exist in the database.
func (q *Queries) GetArtefactDigests(ctx context.Context, digests [][]byte) ([]GetArtefactDigestsRow, error) {
	rows, err := q.db.Query(ctx, getArtefactDigests, digests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArtefactDigestsRow
	for rows.Next() {
		var i GetArtefactDigestsRow
		if err := rows.Scan(&i.ID, &i.Digest); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeployment = `-- name: GetDeployment :one
SELECT deployments.id, deployments.created_at, deployments.module_id, deployments.key, deployments.schema, modules.language, modules.name AS module_name FROM deployments
INNER JOIN modules ON modules.id = deployments.module_id
WHERE deployments.key = $1
`

type GetDeploymentRow struct {
	ID         int64
	CreatedAt  pgtype.Timestamp
	ModuleID   int64
	Key        uuid.UUID
	Schema     []byte
	Language   string
	ModuleName string
}

func (q *Queries) GetDeployment(ctx context.Context, key uuid.UUID) (GetDeploymentRow, error) {
	row := q.db.QueryRow(ctx, getDeployment, key)
	var i GetDeploymentRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ModuleID,
		&i.Key,
		&i.Schema,
		&i.Language,
		&i.ModuleName,
	)
	return i, err
}

const getDeploymentArtefacts = `-- name: GetDeploymentArtefacts :many
SELECT deployment_artefacts.created_at, executable, path, digest, executable, content
FROM deployment_artefacts
INNER JOIN artefacts ON artefacts.id = deployment_artefacts.artefact_id
WHERE deployment_id = $1
`

type GetDeploymentArtefactsRow struct {
	CreatedAt    pgtype.Timestamp
	Executable   bool
	Path         string
	Digest       []byte
	Executable_2 bool
	Content      []byte
}

// Get all artefacts matching the given digests.
func (q *Queries) GetDeploymentArtefacts(ctx context.Context, deploymentID int64) ([]GetDeploymentArtefactsRow, error) {
	rows, err := q.db.Query(ctx, getDeploymentArtefacts, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeploymentArtefactsRow
	for rows.Next() {
		var i GetDeploymentArtefactsRow
		if err := rows.Scan(
			&i.CreatedAt,
			&i.Executable,
			&i.Path,
			&i.Digest,
			&i.Executable_2,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeploymentsWithArtefacts = `-- name: GetDeploymentsWithArtefacts :many
SELECT d.id, d.created_at, d.key, m.name
FROM deployments d
JOIN modules m ON d.module_id = m.id
WHERE EXISTS (
  SELECT 1
  FROM deployment_artefacts da
  JOIN artefacts a ON da.artefact_id = a.id
  WHERE a.digest = ANY($1::bytea[])
    AND da.deployment_id = d.id
  HAVING COUNT(*) = $2 -- Number of unique digests provided
)
`

type GetDeploymentsWithArtefactsParams struct {
	Digests [][]byte
	Count   interface{}
}

type GetDeploymentsWithArtefactsRow struct {
	ID        int64
	CreatedAt pgtype.Timestamp
	Key       uuid.UUID
	Name      string
}

func (q *Queries) GetDeploymentsWithArtefacts(ctx context.Context, arg GetDeploymentsWithArtefactsParams) ([]GetDeploymentsWithArtefactsRow, error) {
	rows, err := q.db.Query(ctx, getDeploymentsWithArtefacts, arg.Digests, arg.Count)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeploymentsWithArtefactsRow
	for rows.Next() {
		var i GetDeploymentsWithArtefactsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Key,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestDeployment = `-- name: GetLatestDeployment :one
SELECT deployments.id, deployments.created_at, deployments.module_id, deployments.key, deployments.schema, modules.language, modules.name AS module_name FROM deployments
INNER JOIN modules ON modules.id = deployments.module_id
WHERE modules.name = $1
ORDER BY created_at DESC LIMIT 1
`

type GetLatestDeploymentRow struct {
	ID         int64
	CreatedAt  pgtype.Timestamp
	ModuleID   int64
	Key        uuid.UUID
	Schema     []byte
	Language   string
	ModuleName string
}

func (q *Queries) GetLatestDeployment(ctx context.Context, moduleName string) (GetLatestDeploymentRow, error) {
	row := q.db.QueryRow(ctx, getLatestDeployment, moduleName)
	var i GetLatestDeploymentRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ModuleID,
		&i.Key,
		&i.Schema,
		&i.Language,
		&i.ModuleName,
	)
	return i, err
}

const listDeployments = `-- name: ListDeployments :many
SELECT id, created_at, module_id, key, schema FROM deployments WHERE module_id = $1
`

func (q *Queries) ListDeployments(ctx context.Context, moduleID int64) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, listDeployments, moduleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Deployment
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.ModuleID,
			&i.Key,
			&i.Schema,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModules = `-- name: ListModules :many
SELECT id, language, name FROM modules
`

func (q *Queries) ListModules(ctx context.Context) ([]Module, error) {
	rows, err := q.db.Query(ctx, listModules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Module
	for rows.Next() {
		var i Module
		if err := rows.Scan(&i.ID, &i.Language, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
