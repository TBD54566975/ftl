// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file opentelemetry/proto/metrics/v1/metrics.proto (package opentelemetry.proto.metrics.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Resource } from "../../resource/v1/resource_pb.js";
import { InstrumentationScope, KeyValue } from "../../common/v1/common_pb.js";

/**
 * AggregationTemporality defines how a metric aggregator reports aggregated
 * values. It describes how those values relate to the time interval over
 * which they are aggregated.
 *
 * @generated from enum opentelemetry.proto.metrics.v1.AggregationTemporality
 */
export enum AggregationTemporality {
  /**
   * UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
   *
   * @generated from enum value: AGGREGATION_TEMPORALITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * DELTA is an AggregationTemporality for a metric aggregator which reports
   * changes since last report time. Successive metrics contain aggregation of
   * values from continuous and non-overlapping intervals.
   *
   * The values for a DELTA metric are based only on the time interval
   * associated with one measurement cycle. There is no dependency on
   * previous measurements like is the case for CUMULATIVE metrics.
   *
   * For example, consider a system measuring the number of requests that
   * it receives and reports the sum of these requests every second as a
   * DELTA metric:
   *
   *   1. The system starts receiving at time=t_0.
   *   2. A request is received, the system measures 1 request.
   *   3. A request is received, the system measures 1 request.
   *   4. A request is received, the system measures 1 request.
   *   5. The 1 second collection cycle ends. A metric is exported for the
   *      number of requests received over the interval of time t_0 to
   *      t_0+1 with a value of 3.
   *   6. A request is received, the system measures 1 request.
   *   7. A request is received, the system measures 1 request.
   *   8. The 1 second collection cycle ends. A metric is exported for the
   *      number of requests received over the interval of time t_0+1 to
   *      t_0+2 with a value of 2.
   *
   * @generated from enum value: AGGREGATION_TEMPORALITY_DELTA = 1;
   */
  DELTA = 1,

  /**
   * CUMULATIVE is an AggregationTemporality for a metric aggregator which
   * reports changes since a fixed start time. This means that current values
   * of a CUMULATIVE metric depend on all previous measurements since the
   * start time. Because of this, the sender is required to retain this state
   * in some form. If this state is lost or invalidated, the CUMULATIVE metric
   * values MUST be reset and a new fixed start time following the last
   * reported measurement time sent MUST be used.
   *
   * For example, consider a system measuring the number of requests that
   * it receives and reports the sum of these requests every second as a
   * CUMULATIVE metric:
   *
   *   1. The system starts receiving at time=t_0.
   *   2. A request is received, the system measures 1 request.
   *   3. A request is received, the system measures 1 request.
   *   4. A request is received, the system measures 1 request.
   *   5. The 1 second collection cycle ends. A metric is exported for the
   *      number of requests received over the interval of time t_0 to
   *      t_0+1 with a value of 3.
   *   6. A request is received, the system measures 1 request.
   *   7. A request is received, the system measures 1 request.
   *   8. The 1 second collection cycle ends. A metric is exported for the
   *      number of requests received over the interval of time t_0 to
   *      t_0+2 with a value of 5.
   *   9. The system experiences a fault and loses state.
   *   10. The system recovers and resumes receiving at time=t_1.
   *   11. A request is received, the system measures 1 request.
   *   12. The 1 second collection cycle ends. A metric is exported for the
   *      number of requests received over the interval of time t_1 to
   *      t_0+1 with a value of 1.
   *
   * Note: Even though, when reporting changes since last report time, using
   * CUMULATIVE is valid, it is not recommended. This may cause problems for
   * systems that do not use start_time to determine when the aggregation
   * value was reset (e.g. Prometheus).
   *
   * @generated from enum value: AGGREGATION_TEMPORALITY_CUMULATIVE = 2;
   */
  CUMULATIVE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AggregationTemporality)
proto3.util.setEnumType(AggregationTemporality, "opentelemetry.proto.metrics.v1.AggregationTemporality", [
  { no: 0, name: "AGGREGATION_TEMPORALITY_UNSPECIFIED" },
  { no: 1, name: "AGGREGATION_TEMPORALITY_DELTA" },
  { no: 2, name: "AGGREGATION_TEMPORALITY_CUMULATIVE" },
]);

/**
 * DataPointFlags is defined as a protobuf 'uint32' type and is to be used as a
 * bit-field representing 32 distinct boolean flags.  Each flag defined in this
 * enum is a bit-mask.  To test the presence of a single flag in the flags of
 * a data point, for example, use an expression like:
 *
 *   (point.flags & DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK) == DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK
 *
 *
 * @generated from enum opentelemetry.proto.metrics.v1.DataPointFlags
 */
export enum DataPointFlags {
  /**
   * The zero value for the enum. Should not be used for comparisons.
   * Instead use bitwise "and" with the appropriate mask as shown above.
   *
   * @generated from enum value: DATA_POINT_FLAGS_DO_NOT_USE = 0;
   */
  DO_NOT_USE = 0,

  /**
   * This DataPoint is valid but has no recorded value.  This value
   * SHOULD be used to reflect explicitly missing data in a series, as
   * for an equivalent to the Prometheus "staleness marker".
   *
   * @generated from enum value: DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK = 1;
   */
  NO_RECORDED_VALUE_MASK = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(DataPointFlags)
proto3.util.setEnumType(DataPointFlags, "opentelemetry.proto.metrics.v1.DataPointFlags", [
  { no: 0, name: "DATA_POINT_FLAGS_DO_NOT_USE" },
  { no: 1, name: "DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK" },
]);

/**
 * MetricsData represents the metrics data that can be stored in a persistent
 * storage, OR can be embedded by other protocols that transfer OTLP metrics
 * data but do not implement the OTLP protocol.
 *
 * The main difference between this message and collector protocol is that
 * in this message there will not be any "control" or "metadata" specific to
 * OTLP protocol.
 *
 * When new fields are added into this message, the OTLP request MUST be updated
 * as well.
 *
 * @generated from message opentelemetry.proto.metrics.v1.MetricsData
 */
export class MetricsData extends Message<MetricsData> {
  /**
   * An array of ResourceMetrics.
   * For data coming from a single resource this array will typically contain
   * one element. Intermediary nodes that receive data from multiple origins
   * typically batch the data before forwarding further and in that case this
   * array will contain multiple elements.
   *
   * @generated from field: repeated opentelemetry.proto.metrics.v1.ResourceMetrics resource_metrics = 1;
   */
  resourceMetrics: ResourceMetrics[] = [];

  constructor(data?: PartialMessage<MetricsData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.MetricsData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource_metrics", kind: "message", T: ResourceMetrics, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsData {
    return new MetricsData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsData {
    return new MetricsData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsData {
    return new MetricsData().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsData | PlainMessage<MetricsData> | undefined, b: MetricsData | PlainMessage<MetricsData> | undefined): boolean {
    return proto3.util.equals(MetricsData, a, b);
  }
}

/**
 * A collection of ScopeMetrics from a Resource.
 *
 * @generated from message opentelemetry.proto.metrics.v1.ResourceMetrics
 */
export class ResourceMetrics extends Message<ResourceMetrics> {
  /**
   * The resource for the metrics in this message.
   * If this field is not set then no resource info is known.
   *
   * @generated from field: opentelemetry.proto.resource.v1.Resource resource = 1;
   */
  resource?: Resource;

  /**
   * A list of metrics that originate from a resource.
   *
   * @generated from field: repeated opentelemetry.proto.metrics.v1.ScopeMetrics scope_metrics = 2;
   */
  scopeMetrics: ScopeMetrics[] = [];

  /**
   * This schema_url applies to the data in the "resource" field. It does not apply
   * to the data in the "scope_metrics" field which have their own schema_url field.
   *
   * @generated from field: string schema_url = 3;
   */
  schemaUrl = "";

  constructor(data?: PartialMessage<ResourceMetrics>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.ResourceMetrics";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource", kind: "message", T: Resource },
    { no: 2, name: "scope_metrics", kind: "message", T: ScopeMetrics, repeated: true },
    { no: 3, name: "schema_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceMetrics {
    return new ResourceMetrics().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceMetrics {
    return new ResourceMetrics().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceMetrics {
    return new ResourceMetrics().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceMetrics | PlainMessage<ResourceMetrics> | undefined, b: ResourceMetrics | PlainMessage<ResourceMetrics> | undefined): boolean {
    return proto3.util.equals(ResourceMetrics, a, b);
  }
}

/**
 * A collection of Metrics produced by an Scope.
 *
 * @generated from message opentelemetry.proto.metrics.v1.ScopeMetrics
 */
export class ScopeMetrics extends Message<ScopeMetrics> {
  /**
   * The instrumentation scope information for the metrics in this message.
   * Semantically when InstrumentationScope isn't set, it is equivalent with
   * an empty instrumentation scope name (unknown).
   *
   * @generated from field: opentelemetry.proto.common.v1.InstrumentationScope scope = 1;
   */
  scope?: InstrumentationScope;

  /**
   * A list of metrics that originate from an instrumentation library.
   *
   * @generated from field: repeated opentelemetry.proto.metrics.v1.Metric metrics = 2;
   */
  metrics: Metric[] = [];

  /**
   * This schema_url applies to all metrics in the "metrics" field.
   *
   * @generated from field: string schema_url = 3;
   */
  schemaUrl = "";

  constructor(data?: PartialMessage<ScopeMetrics>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.ScopeMetrics";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scope", kind: "message", T: InstrumentationScope },
    { no: 2, name: "metrics", kind: "message", T: Metric, repeated: true },
    { no: 3, name: "schema_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScopeMetrics {
    return new ScopeMetrics().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScopeMetrics {
    return new ScopeMetrics().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScopeMetrics {
    return new ScopeMetrics().fromJsonString(jsonString, options);
  }

  static equals(a: ScopeMetrics | PlainMessage<ScopeMetrics> | undefined, b: ScopeMetrics | PlainMessage<ScopeMetrics> | undefined): boolean {
    return proto3.util.equals(ScopeMetrics, a, b);
  }
}

/**
 * Defines a Metric which has one or more timeseries.  The following is a
 * brief summary of the Metric data model.  For more details, see:
 *
 *   https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/data-model.md
 *
 *
 * The data model and relation between entities is shown in the
 * diagram below. Here, "DataPoint" is the term used to refer to any
 * one of the specific data point value types, and "points" is the term used
 * to refer to any one of the lists of points contained in the Metric.
 *
 * - Metric is composed of a metadata and data.
 * - Metadata part contains a name, description, unit.
 * - Data is one of the possible types (Sum, Gauge, Histogram, Summary).
 * - DataPoint contains timestamps, attributes, and one of the possible value type
 *   fields.
 *
 *     Metric
 *  +------------+
 *  |name        |
 *  |description |
 *  |unit        |     +------------------------------------+
 *  |data        |---> |Gauge, Sum, Histogram, Summary, ... |
 *  +------------+     +------------------------------------+
 *
 *    Data [One of Gauge, Sum, Histogram, Summary, ...]
 *  +-----------+
 *  |...        |  // Metadata about the Data.
 *  |points     |--+
 *  +-----------+  |
 *                 |      +---------------------------+
 *                 |      |DataPoint 1                |
 *                 v      |+------+------+   +------+ |
 *              +-----+   ||label |label |...|label | |
 *              |  1  |-->||value1|value2|...|valueN| |
 *              +-----+   |+------+------+   +------+ |
 *              |  .  |   |+-----+                    |
 *              |  .  |   ||value|                    |
 *              |  .  |   |+-----+                    |
 *              |  .  |   +---------------------------+
 *              |  .  |                   .
 *              |  .  |                   .
 *              |  .  |                   .
 *              |  .  |   +---------------------------+
 *              |  .  |   |DataPoint M                |
 *              +-----+   |+------+------+   +------+ |
 *              |  M  |-->||label |label |...|label | |
 *              +-----+   ||value1|value2|...|valueN| |
 *                        |+------+------+   +------+ |
 *                        |+-----+                    |
 *                        ||value|                    |
 *                        |+-----+                    |
 *                        +---------------------------+
 *
 * Each distinct type of DataPoint represents the output of a specific
 * aggregation function, the result of applying the DataPoint's
 * associated function of to one or more measurements.
 *
 * All DataPoint types have three common fields:
 * - Attributes includes key-value pairs associated with the data point
 * - TimeUnixNano is required, set to the end time of the aggregation
 * - StartTimeUnixNano is optional, but strongly encouraged for DataPoints
 *   having an AggregationTemporality field, as discussed below.
 *
 * Both TimeUnixNano and StartTimeUnixNano values are expressed as
 * UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
 *
 * # TimeUnixNano
 *
 * This field is required, having consistent interpretation across
 * DataPoint types.  TimeUnixNano is the moment corresponding to when
 * the data point's aggregate value was captured.
 *
 * Data points with the 0 value for TimeUnixNano SHOULD be rejected
 * by consumers.
 *
 * # StartTimeUnixNano
 *
 * StartTimeUnixNano in general allows detecting when a sequence of
 * observations is unbroken.  This field indicates to consumers the
 * start time for points with cumulative and delta
 * AggregationTemporality, and it should be included whenever possible
 * to support correct rate calculation.  Although it may be omitted
 * when the start time is truly unknown, setting StartTimeUnixNano is
 * strongly encouraged.
 *
 * @generated from message opentelemetry.proto.metrics.v1.Metric
 */
export class Metric extends Message<Metric> {
  /**
   * name of the metric, including its DNS name prefix. It must be unique.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * description of the metric, which can be used in documentation.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * unit in which the metric value is reported. Follows the format
   * described by http://unitsofmeasure.org/ucum.html.
   *
   * @generated from field: string unit = 3;
   */
  unit = "";

  /**
   * Data determines the aggregation type (if any) of the metric, what is the
   * reported value type for the data points, as well as the relatationship to
   * the time interval over which they are reported.
   *
   * @generated from oneof opentelemetry.proto.metrics.v1.Metric.data
   */
  data: {
    /**
     * @generated from field: opentelemetry.proto.metrics.v1.Gauge gauge = 5;
     */
    value: Gauge;
    case: "gauge";
  } | {
    /**
     * @generated from field: opentelemetry.proto.metrics.v1.Sum sum = 7;
     */
    value: Sum;
    case: "sum";
  } | {
    /**
     * @generated from field: opentelemetry.proto.metrics.v1.Histogram histogram = 9;
     */
    value: Histogram;
    case: "histogram";
  } | {
    /**
     * @generated from field: opentelemetry.proto.metrics.v1.ExponentialHistogram exponential_histogram = 10;
     */
    value: ExponentialHistogram;
    case: "exponentialHistogram";
  } | {
    /**
     * @generated from field: opentelemetry.proto.metrics.v1.Summary summary = 11;
     */
    value: Summary;
    case: "summary";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Metric>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.Metric";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "gauge", kind: "message", T: Gauge, oneof: "data" },
    { no: 7, name: "sum", kind: "message", T: Sum, oneof: "data" },
    { no: 9, name: "histogram", kind: "message", T: Histogram, oneof: "data" },
    { no: 10, name: "exponential_histogram", kind: "message", T: ExponentialHistogram, oneof: "data" },
    { no: 11, name: "summary", kind: "message", T: Summary, oneof: "data" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metric {
    return new Metric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metric {
    return new Metric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metric {
    return new Metric().fromJsonString(jsonString, options);
  }

  static equals(a: Metric | PlainMessage<Metric> | undefined, b: Metric | PlainMessage<Metric> | undefined): boolean {
    return proto3.util.equals(Metric, a, b);
  }
}

/**
 * Gauge represents the type of a scalar metric that always exports the
 * "current value" for every data point. It should be used for an "unknown"
 * aggregation.
 *
 * A Gauge does not support different aggregation temporalities. Given the
 * aggregation is unknown, points cannot be combined using the same
 * aggregation, regardless of aggregation temporalities. Therefore,
 * AggregationTemporality is not included. Consequently, this also means
 * "StartTimeUnixNano" is ignored for all data points.
 *
 * @generated from message opentelemetry.proto.metrics.v1.Gauge
 */
export class Gauge extends Message<Gauge> {
  /**
   * @generated from field: repeated opentelemetry.proto.metrics.v1.NumberDataPoint data_points = 1;
   */
  dataPoints: NumberDataPoint[] = [];

  constructor(data?: PartialMessage<Gauge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.Gauge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data_points", kind: "message", T: NumberDataPoint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Gauge {
    return new Gauge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Gauge {
    return new Gauge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Gauge {
    return new Gauge().fromJsonString(jsonString, options);
  }

  static equals(a: Gauge | PlainMessage<Gauge> | undefined, b: Gauge | PlainMessage<Gauge> | undefined): boolean {
    return proto3.util.equals(Gauge, a, b);
  }
}

/**
 * Sum represents the type of a scalar metric that is calculated as a sum of all
 * reported measurements over a time interval.
 *
 * @generated from message opentelemetry.proto.metrics.v1.Sum
 */
export class Sum extends Message<Sum> {
  /**
   * @generated from field: repeated opentelemetry.proto.metrics.v1.NumberDataPoint data_points = 1;
   */
  dataPoints: NumberDataPoint[] = [];

  /**
   * aggregation_temporality describes if the aggregator reports delta changes
   * since last report time, or cumulative changes since a fixed start time.
   *
   * @generated from field: opentelemetry.proto.metrics.v1.AggregationTemporality aggregation_temporality = 2;
   */
  aggregationTemporality = AggregationTemporality.UNSPECIFIED;

  /**
   * If "true" means that the sum is monotonic.
   *
   * @generated from field: bool is_monotonic = 3;
   */
  isMonotonic = false;

  constructor(data?: PartialMessage<Sum>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.Sum";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data_points", kind: "message", T: NumberDataPoint, repeated: true },
    { no: 2, name: "aggregation_temporality", kind: "enum", T: proto3.getEnumType(AggregationTemporality) },
    { no: 3, name: "is_monotonic", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Sum {
    return new Sum().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Sum {
    return new Sum().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Sum {
    return new Sum().fromJsonString(jsonString, options);
  }

  static equals(a: Sum | PlainMessage<Sum> | undefined, b: Sum | PlainMessage<Sum> | undefined): boolean {
    return proto3.util.equals(Sum, a, b);
  }
}

/**
 * Histogram represents the type of a metric that is calculated by aggregating
 * as a Histogram of all reported measurements over a time interval.
 *
 * @generated from message opentelemetry.proto.metrics.v1.Histogram
 */
export class Histogram extends Message<Histogram> {
  /**
   * @generated from field: repeated opentelemetry.proto.metrics.v1.HistogramDataPoint data_points = 1;
   */
  dataPoints: HistogramDataPoint[] = [];

  /**
   * aggregation_temporality describes if the aggregator reports delta changes
   * since last report time, or cumulative changes since a fixed start time.
   *
   * @generated from field: opentelemetry.proto.metrics.v1.AggregationTemporality aggregation_temporality = 2;
   */
  aggregationTemporality = AggregationTemporality.UNSPECIFIED;

  constructor(data?: PartialMessage<Histogram>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.Histogram";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data_points", kind: "message", T: HistogramDataPoint, repeated: true },
    { no: 2, name: "aggregation_temporality", kind: "enum", T: proto3.getEnumType(AggregationTemporality) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Histogram {
    return new Histogram().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Histogram {
    return new Histogram().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Histogram {
    return new Histogram().fromJsonString(jsonString, options);
  }

  static equals(a: Histogram | PlainMessage<Histogram> | undefined, b: Histogram | PlainMessage<Histogram> | undefined): boolean {
    return proto3.util.equals(Histogram, a, b);
  }
}

/**
 * ExponentialHistogram represents the type of a metric that is calculated by aggregating
 * as a ExponentialHistogram of all reported double measurements over a time interval.
 *
 * @generated from message opentelemetry.proto.metrics.v1.ExponentialHistogram
 */
export class ExponentialHistogram extends Message<ExponentialHistogram> {
  /**
   * @generated from field: repeated opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint data_points = 1;
   */
  dataPoints: ExponentialHistogramDataPoint[] = [];

  /**
   * aggregation_temporality describes if the aggregator reports delta changes
   * since last report time, or cumulative changes since a fixed start time.
   *
   * @generated from field: opentelemetry.proto.metrics.v1.AggregationTemporality aggregation_temporality = 2;
   */
  aggregationTemporality = AggregationTemporality.UNSPECIFIED;

  constructor(data?: PartialMessage<ExponentialHistogram>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.ExponentialHistogram";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data_points", kind: "message", T: ExponentialHistogramDataPoint, repeated: true },
    { no: 2, name: "aggregation_temporality", kind: "enum", T: proto3.getEnumType(AggregationTemporality) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExponentialHistogram {
    return new ExponentialHistogram().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExponentialHistogram {
    return new ExponentialHistogram().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExponentialHistogram {
    return new ExponentialHistogram().fromJsonString(jsonString, options);
  }

  static equals(a: ExponentialHistogram | PlainMessage<ExponentialHistogram> | undefined, b: ExponentialHistogram | PlainMessage<ExponentialHistogram> | undefined): boolean {
    return proto3.util.equals(ExponentialHistogram, a, b);
  }
}

/**
 * Summary metric data are used to convey quantile summaries,
 * a Prometheus (see: https://prometheus.io/docs/concepts/metric_types/#summary)
 * and OpenMetrics (see: https://github.com/OpenObservability/OpenMetrics/blob/4dbf6075567ab43296eed941037c12951faafb92/protos/prometheus.proto#L45)
 * data type. These data points cannot always be merged in a meaningful way.
 * While they can be useful in some applications, histogram data points are
 * recommended for new applications.
 *
 * @generated from message opentelemetry.proto.metrics.v1.Summary
 */
export class Summary extends Message<Summary> {
  /**
   * @generated from field: repeated opentelemetry.proto.metrics.v1.SummaryDataPoint data_points = 1;
   */
  dataPoints: SummaryDataPoint[] = [];

  constructor(data?: PartialMessage<Summary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.Summary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data_points", kind: "message", T: SummaryDataPoint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Summary {
    return new Summary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Summary {
    return new Summary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Summary {
    return new Summary().fromJsonString(jsonString, options);
  }

  static equals(a: Summary | PlainMessage<Summary> | undefined, b: Summary | PlainMessage<Summary> | undefined): boolean {
    return proto3.util.equals(Summary, a, b);
  }
}

/**
 * NumberDataPoint is a single data point in a timeseries that describes the
 * time-varying scalar value of a metric.
 *
 * @generated from message opentelemetry.proto.metrics.v1.NumberDataPoint
 */
export class NumberDataPoint extends Message<NumberDataPoint> {
  /**
   * The set of key/value pairs that uniquely identify the timeseries from
   * where this point belongs. The list may be empty (may contain 0 elements).
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   *
   * @generated from field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 7;
   */
  attributes: KeyValue[] = [];

  /**
   * StartTimeUnixNano is optional but strongly encouraged, see the
   * the detailed comments above Metric.
   *
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   *
   * @generated from field: fixed64 start_time_unix_nano = 2;
   */
  startTimeUnixNano = protoInt64.zero;

  /**
   * TimeUnixNano is required, see the detailed comments above Metric.
   *
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   *
   * @generated from field: fixed64 time_unix_nano = 3;
   */
  timeUnixNano = protoInt64.zero;

  /**
   * The value itself.  A point is considered invalid when one of the recognized
   * value fields is not present inside this oneof.
   *
   * @generated from oneof opentelemetry.proto.metrics.v1.NumberDataPoint.value
   */
  value: {
    /**
     * @generated from field: double as_double = 4;
     */
    value: number;
    case: "asDouble";
  } | {
    /**
     * @generated from field: sfixed64 as_int = 6;
     */
    value: bigint;
    case: "asInt";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * (Optional) List of exemplars collected from
   * measurements that were used to form the data point
   *
   * @generated from field: repeated opentelemetry.proto.metrics.v1.Exemplar exemplars = 5;
   */
  exemplars: Exemplar[] = [];

  /**
   * Flags that apply to this specific data point.  See DataPointFlags
   * for the available flags and their meaning.
   *
   * @generated from field: uint32 flags = 8;
   */
  flags = 0;

  constructor(data?: PartialMessage<NumberDataPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.NumberDataPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 7, name: "attributes", kind: "message", T: KeyValue, repeated: true },
    { no: 2, name: "start_time_unix_nano", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 3, name: "time_unix_nano", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 4, name: "as_double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "value" },
    { no: 6, name: "as_int", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, oneof: "value" },
    { no: 5, name: "exemplars", kind: "message", T: Exemplar, repeated: true },
    { no: 8, name: "flags", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NumberDataPoint {
    return new NumberDataPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NumberDataPoint {
    return new NumberDataPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NumberDataPoint {
    return new NumberDataPoint().fromJsonString(jsonString, options);
  }

  static equals(a: NumberDataPoint | PlainMessage<NumberDataPoint> | undefined, b: NumberDataPoint | PlainMessage<NumberDataPoint> | undefined): boolean {
    return proto3.util.equals(NumberDataPoint, a, b);
  }
}

/**
 * HistogramDataPoint is a single data point in a timeseries that describes the
 * time-varying values of a Histogram. A Histogram contains summary statistics
 * for a population of values, it may optionally contain the distribution of
 * those values across a set of buckets.
 *
 * If the histogram contains the distribution of values, then both
 * "explicit_bounds" and "bucket counts" fields must be defined.
 * If the histogram does not contain the distribution of values, then both
 * "explicit_bounds" and "bucket_counts" must be omitted and only "count" and
 * "sum" are known.
 *
 * @generated from message opentelemetry.proto.metrics.v1.HistogramDataPoint
 */
export class HistogramDataPoint extends Message<HistogramDataPoint> {
  /**
   * The set of key/value pairs that uniquely identify the timeseries from
   * where this point belongs. The list may be empty (may contain 0 elements).
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   *
   * @generated from field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 9;
   */
  attributes: KeyValue[] = [];

  /**
   * StartTimeUnixNano is optional but strongly encouraged, see the
   * the detailed comments above Metric.
   *
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   *
   * @generated from field: fixed64 start_time_unix_nano = 2;
   */
  startTimeUnixNano = protoInt64.zero;

  /**
   * TimeUnixNano is required, see the detailed comments above Metric.
   *
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   *
   * @generated from field: fixed64 time_unix_nano = 3;
   */
  timeUnixNano = protoInt64.zero;

  /**
   * count is the number of values in the population. Must be non-negative. This
   * value must be equal to the sum of the "count" fields in buckets if a
   * histogram is provided.
   *
   * @generated from field: fixed64 count = 4;
   */
  count = protoInt64.zero;

  /**
   * sum of the values in the population. If count is zero then this field
   * must be zero.
   *
   * Note: Sum should only be filled out when measuring non-negative discrete
   * events, and is assumed to be monotonic over the values of these events.
   * Negative events *can* be recorded, but sum should not be filled out when
   * doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
   * see: https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#histogram
   *
   * @generated from field: optional double sum = 5;
   */
  sum?: number;

  /**
   * bucket_counts is an optional field contains the count values of histogram
   * for each bucket.
   *
   * The sum of the bucket_counts must equal the value in the count field.
   *
   * The number of elements in bucket_counts array must be by one greater than
   * the number of elements in explicit_bounds array.
   *
   * @generated from field: repeated fixed64 bucket_counts = 6;
   */
  bucketCounts: bigint[] = [];

  /**
   * explicit_bounds specifies buckets with explicitly defined bounds for values.
   *
   * The boundaries for bucket at index i are:
   *
   * (-infinity, explicit_bounds[i]] for i == 0
   * (explicit_bounds[i-1], explicit_bounds[i]] for 0 < i < size(explicit_bounds)
   * (explicit_bounds[i-1], +infinity) for i == size(explicit_bounds)
   *
   * The values in the explicit_bounds array must be strictly increasing.
   *
   * Histogram buckets are inclusive of their upper boundary, except the last
   * bucket where the boundary is at infinity. This format is intentionally
   * compatible with the OpenMetrics histogram definition.
   *
   * @generated from field: repeated double explicit_bounds = 7;
   */
  explicitBounds: number[] = [];

  /**
   * (Optional) List of exemplars collected from
   * measurements that were used to form the data point
   *
   * @generated from field: repeated opentelemetry.proto.metrics.v1.Exemplar exemplars = 8;
   */
  exemplars: Exemplar[] = [];

  /**
   * Flags that apply to this specific data point.  See DataPointFlags
   * for the available flags and their meaning.
   *
   * @generated from field: uint32 flags = 10;
   */
  flags = 0;

  /**
   * min is the minimum value over (start_time, end_time].
   *
   * @generated from field: optional double min = 11;
   */
  min?: number;

  /**
   * max is the maximum value over (start_time, end_time].
   *
   * @generated from field: optional double max = 12;
   */
  max?: number;

  constructor(data?: PartialMessage<HistogramDataPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.HistogramDataPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 9, name: "attributes", kind: "message", T: KeyValue, repeated: true },
    { no: 2, name: "start_time_unix_nano", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 3, name: "time_unix_nano", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 4, name: "count", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 5, name: "sum", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 6, name: "bucket_counts", kind: "scalar", T: 6 /* ScalarType.FIXED64 */, repeated: true },
    { no: 7, name: "explicit_bounds", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
    { no: 8, name: "exemplars", kind: "message", T: Exemplar, repeated: true },
    { no: 10, name: "flags", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 11, name: "min", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 12, name: "max", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HistogramDataPoint {
    return new HistogramDataPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HistogramDataPoint {
    return new HistogramDataPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HistogramDataPoint {
    return new HistogramDataPoint().fromJsonString(jsonString, options);
  }

  static equals(a: HistogramDataPoint | PlainMessage<HistogramDataPoint> | undefined, b: HistogramDataPoint | PlainMessage<HistogramDataPoint> | undefined): boolean {
    return proto3.util.equals(HistogramDataPoint, a, b);
  }
}

/**
 * ExponentialHistogramDataPoint is a single data point in a timeseries that describes the
 * time-varying values of a ExponentialHistogram of double values. A ExponentialHistogram contains
 * summary statistics for a population of values, it may optionally contain the
 * distribution of those values across a set of buckets.
 *
 *
 * @generated from message opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
 */
export class ExponentialHistogramDataPoint extends Message<ExponentialHistogramDataPoint> {
  /**
   * The set of key/value pairs that uniquely identify the timeseries from
   * where this point belongs. The list may be empty (may contain 0 elements).
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   *
   * @generated from field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 1;
   */
  attributes: KeyValue[] = [];

  /**
   * StartTimeUnixNano is optional but strongly encouraged, see the
   * the detailed comments above Metric.
   *
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   *
   * @generated from field: fixed64 start_time_unix_nano = 2;
   */
  startTimeUnixNano = protoInt64.zero;

  /**
   * TimeUnixNano is required, see the detailed comments above Metric.
   *
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   *
   * @generated from field: fixed64 time_unix_nano = 3;
   */
  timeUnixNano = protoInt64.zero;

  /**
   * count is the number of values in the population. Must be
   * non-negative. This value must be equal to the sum of the "bucket_counts"
   * values in the positive and negative Buckets plus the "zero_count" field.
   *
   * @generated from field: fixed64 count = 4;
   */
  count = protoInt64.zero;

  /**
   * sum of the values in the population. If count is zero then this field
   * must be zero.
   *
   * Note: Sum should only be filled out when measuring non-negative discrete
   * events, and is assumed to be monotonic over the values of these events.
   * Negative events *can* be recorded, but sum should not be filled out when
   * doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
   * see: https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#histogram
   *
   * @generated from field: optional double sum = 5;
   */
  sum?: number;

  /**
   * scale describes the resolution of the histogram.  Boundaries are
   * located at powers of the base, where:
   *
   *   base = (2^(2^-scale))
   *
   * The histogram bucket identified by `index`, a signed integer,
   * contains values that are greater than (base^index) and
   * less than or equal to (base^(index+1)).
   *
   * The positive and negative ranges of the histogram are expressed
   * separately.  Negative values are mapped by their absolute value
   * into the negative range using the same scale as the positive range.
   *
   * scale is not restricted by the protocol, as the permissible
   * values depend on the range of the data.
   *
   * @generated from field: sint32 scale = 6;
   */
  scale = 0;

  /**
   * zero_count is the count of values that are either exactly zero or
   * within the region considered zero by the instrumentation at the
   * tolerated degree of precision.  This bucket stores values that
   * cannot be expressed using the standard exponential formula as
   * well as values that have been rounded to zero.
   *
   * Implementations MAY consider the zero bucket to have probability
   * mass equal to (zero_count / count).
   *
   * @generated from field: fixed64 zero_count = 7;
   */
  zeroCount = protoInt64.zero;

  /**
   * positive carries the positive range of exponential bucket counts.
   *
   * @generated from field: opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets positive = 8;
   */
  positive?: ExponentialHistogramDataPoint_Buckets;

  /**
   * negative carries the negative range of exponential bucket counts.
   *
   * @generated from field: opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets negative = 9;
   */
  negative?: ExponentialHistogramDataPoint_Buckets;

  /**
   * Flags that apply to this specific data point.  See DataPointFlags
   * for the available flags and their meaning.
   *
   * @generated from field: uint32 flags = 10;
   */
  flags = 0;

  /**
   * (Optional) List of exemplars collected from
   * measurements that were used to form the data point
   *
   * @generated from field: repeated opentelemetry.proto.metrics.v1.Exemplar exemplars = 11;
   */
  exemplars: Exemplar[] = [];

  /**
   * min is the minimum value over (start_time, end_time].
   *
   * @generated from field: optional double min = 12;
   */
  min?: number;

  /**
   * max is the maximum value over (start_time, end_time].
   *
   * @generated from field: optional double max = 13;
   */
  max?: number;

  /**
   * ZeroThreshold may be optionally set to convey the width of the zero
   * region. Where the zero region is defined as the closed interval
   * [-ZeroThreshold, ZeroThreshold].
   * When ZeroThreshold is 0, zero count bucket stores values that cannot be
   * expressed using the standard exponential formula as well as values that
   * have been rounded to zero.
   *
   * @generated from field: double zero_threshold = 14;
   */
  zeroThreshold = 0;

  constructor(data?: PartialMessage<ExponentialHistogramDataPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "attributes", kind: "message", T: KeyValue, repeated: true },
    { no: 2, name: "start_time_unix_nano", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 3, name: "time_unix_nano", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 4, name: "count", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 5, name: "sum", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 6, name: "scale", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
    { no: 7, name: "zero_count", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 8, name: "positive", kind: "message", T: ExponentialHistogramDataPoint_Buckets },
    { no: 9, name: "negative", kind: "message", T: ExponentialHistogramDataPoint_Buckets },
    { no: 10, name: "flags", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 11, name: "exemplars", kind: "message", T: Exemplar, repeated: true },
    { no: 12, name: "min", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 13, name: "max", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 14, name: "zero_threshold", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExponentialHistogramDataPoint {
    return new ExponentialHistogramDataPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExponentialHistogramDataPoint {
    return new ExponentialHistogramDataPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExponentialHistogramDataPoint {
    return new ExponentialHistogramDataPoint().fromJsonString(jsonString, options);
  }

  static equals(a: ExponentialHistogramDataPoint | PlainMessage<ExponentialHistogramDataPoint> | undefined, b: ExponentialHistogramDataPoint | PlainMessage<ExponentialHistogramDataPoint> | undefined): boolean {
    return proto3.util.equals(ExponentialHistogramDataPoint, a, b);
  }
}

/**
 * Buckets are a set of bucket counts, encoded in a contiguous array
 * of counts.
 *
 * @generated from message opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
 */
export class ExponentialHistogramDataPoint_Buckets extends Message<ExponentialHistogramDataPoint_Buckets> {
  /**
   * Offset is the bucket index of the first entry in the bucket_counts array.
   *
   * Note: This uses a varint encoding as a simple form of compression.
   *
   * @generated from field: sint32 offset = 1;
   */
  offset = 0;

  /**
   * bucket_counts is an array of count values, where bucket_counts[i] carries
   * the count of the bucket at index (offset+i). bucket_counts[i] is the count
   * of values greater than base^(offset+i) and less than or equal to
   * base^(offset+i+1).
   *
   * Note: By contrast, the explicit HistogramDataPoint uses
   * fixed64.  This field is expected to have many buckets,
   * especially zeros, so uint64 has been selected to ensure
   * varint encoding.
   *
   * @generated from field: repeated uint64 bucket_counts = 2;
   */
  bucketCounts: bigint[] = [];

  constructor(data?: PartialMessage<ExponentialHistogramDataPoint_Buckets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "offset", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
    { no: 2, name: "bucket_counts", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExponentialHistogramDataPoint_Buckets {
    return new ExponentialHistogramDataPoint_Buckets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExponentialHistogramDataPoint_Buckets {
    return new ExponentialHistogramDataPoint_Buckets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExponentialHistogramDataPoint_Buckets {
    return new ExponentialHistogramDataPoint_Buckets().fromJsonString(jsonString, options);
  }

  static equals(a: ExponentialHistogramDataPoint_Buckets | PlainMessage<ExponentialHistogramDataPoint_Buckets> | undefined, b: ExponentialHistogramDataPoint_Buckets | PlainMessage<ExponentialHistogramDataPoint_Buckets> | undefined): boolean {
    return proto3.util.equals(ExponentialHistogramDataPoint_Buckets, a, b);
  }
}

/**
 * SummaryDataPoint is a single data point in a timeseries that describes the
 * time-varying values of a Summary metric.
 *
 * @generated from message opentelemetry.proto.metrics.v1.SummaryDataPoint
 */
export class SummaryDataPoint extends Message<SummaryDataPoint> {
  /**
   * The set of key/value pairs that uniquely identify the timeseries from
   * where this point belongs. The list may be empty (may contain 0 elements).
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   *
   * @generated from field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 7;
   */
  attributes: KeyValue[] = [];

  /**
   * StartTimeUnixNano is optional but strongly encouraged, see the
   * the detailed comments above Metric.
   *
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   *
   * @generated from field: fixed64 start_time_unix_nano = 2;
   */
  startTimeUnixNano = protoInt64.zero;

  /**
   * TimeUnixNano is required, see the detailed comments above Metric.
   *
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   *
   * @generated from field: fixed64 time_unix_nano = 3;
   */
  timeUnixNano = protoInt64.zero;

  /**
   * count is the number of values in the population. Must be non-negative.
   *
   * @generated from field: fixed64 count = 4;
   */
  count = protoInt64.zero;

  /**
   * sum of the values in the population. If count is zero then this field
   * must be zero.
   *
   * Note: Sum should only be filled out when measuring non-negative discrete
   * events, and is assumed to be monotonic over the values of these events.
   * Negative events *can* be recorded, but sum should not be filled out when
   * doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
   * see: https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#summary
   *
   * @generated from field: double sum = 5;
   */
  sum = 0;

  /**
   * (Optional) list of values at different quantiles of the distribution calculated
   * from the current snapshot. The quantiles must be strictly increasing.
   *
   * @generated from field: repeated opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile quantile_values = 6;
   */
  quantileValues: SummaryDataPoint_ValueAtQuantile[] = [];

  /**
   * Flags that apply to this specific data point.  See DataPointFlags
   * for the available flags and their meaning.
   *
   * @generated from field: uint32 flags = 8;
   */
  flags = 0;

  constructor(data?: PartialMessage<SummaryDataPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.SummaryDataPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 7, name: "attributes", kind: "message", T: KeyValue, repeated: true },
    { no: 2, name: "start_time_unix_nano", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 3, name: "time_unix_nano", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 4, name: "count", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 5, name: "sum", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "quantile_values", kind: "message", T: SummaryDataPoint_ValueAtQuantile, repeated: true },
    { no: 8, name: "flags", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SummaryDataPoint {
    return new SummaryDataPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SummaryDataPoint {
    return new SummaryDataPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SummaryDataPoint {
    return new SummaryDataPoint().fromJsonString(jsonString, options);
  }

  static equals(a: SummaryDataPoint | PlainMessage<SummaryDataPoint> | undefined, b: SummaryDataPoint | PlainMessage<SummaryDataPoint> | undefined): boolean {
    return proto3.util.equals(SummaryDataPoint, a, b);
  }
}

/**
 * Represents the value at a given quantile of a distribution.
 *
 * To record Min and Max values following conventions are used:
 * - The 1.0 quantile is equivalent to the maximum value observed.
 * - The 0.0 quantile is equivalent to the minimum value observed.
 *
 * See the following issue for more context:
 * https://github.com/open-telemetry/opentelemetry-proto/issues/125
 *
 * @generated from message opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
 */
export class SummaryDataPoint_ValueAtQuantile extends Message<SummaryDataPoint_ValueAtQuantile> {
  /**
   * The quantile of a distribution. Must be in the interval
   * [0.0, 1.0].
   *
   * @generated from field: double quantile = 1;
   */
  quantile = 0;

  /**
   * The value at the given quantile of a distribution.
   *
   * Quantile values must NOT be negative.
   *
   * @generated from field: double value = 2;
   */
  value = 0;

  constructor(data?: PartialMessage<SummaryDataPoint_ValueAtQuantile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quantile", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SummaryDataPoint_ValueAtQuantile {
    return new SummaryDataPoint_ValueAtQuantile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SummaryDataPoint_ValueAtQuantile {
    return new SummaryDataPoint_ValueAtQuantile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SummaryDataPoint_ValueAtQuantile {
    return new SummaryDataPoint_ValueAtQuantile().fromJsonString(jsonString, options);
  }

  static equals(a: SummaryDataPoint_ValueAtQuantile | PlainMessage<SummaryDataPoint_ValueAtQuantile> | undefined, b: SummaryDataPoint_ValueAtQuantile | PlainMessage<SummaryDataPoint_ValueAtQuantile> | undefined): boolean {
    return proto3.util.equals(SummaryDataPoint_ValueAtQuantile, a, b);
  }
}

/**
 * A representation of an exemplar, which is a sample input measurement.
 * Exemplars also hold information about the environment when the measurement
 * was recorded, for example the span and trace ID of the active span when the
 * exemplar was recorded.
 *
 * @generated from message opentelemetry.proto.metrics.v1.Exemplar
 */
export class Exemplar extends Message<Exemplar> {
  /**
   * The set of key/value pairs that were filtered out by the aggregator, but
   * recorded alongside the original measurement. Only key/value pairs that were
   * filtered out by the aggregator should be included
   *
   * @generated from field: repeated opentelemetry.proto.common.v1.KeyValue filtered_attributes = 7;
   */
  filteredAttributes: KeyValue[] = [];

  /**
   * time_unix_nano is the exact time when this exemplar was recorded
   *
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   *
   * @generated from field: fixed64 time_unix_nano = 2;
   */
  timeUnixNano = protoInt64.zero;

  /**
   * The value of the measurement that was recorded. An exemplar is
   * considered invalid when one of the recognized value fields is not present
   * inside this oneof.
   *
   * @generated from oneof opentelemetry.proto.metrics.v1.Exemplar.value
   */
  value: {
    /**
     * @generated from field: double as_double = 3;
     */
    value: number;
    case: "asDouble";
  } | {
    /**
     * @generated from field: sfixed64 as_int = 6;
     */
    value: bigint;
    case: "asInt";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * (Optional) Span ID of the exemplar trace.
   * span_id may be missing if the measurement is not recorded inside a trace
   * or if the trace is not sampled.
   *
   * @generated from field: bytes span_id = 4;
   */
  spanId = new Uint8Array(0);

  /**
   * (Optional) Trace ID of the exemplar trace.
   * trace_id may be missing if the measurement is not recorded inside a trace
   * or if the trace is not sampled.
   *
   * @generated from field: bytes trace_id = 5;
   */
  traceId = new Uint8Array(0);

  constructor(data?: PartialMessage<Exemplar>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "opentelemetry.proto.metrics.v1.Exemplar";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 7, name: "filtered_attributes", kind: "message", T: KeyValue, repeated: true },
    { no: 2, name: "time_unix_nano", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 3, name: "as_double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "value" },
    { no: 6, name: "as_int", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, oneof: "value" },
    { no: 4, name: "span_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "trace_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Exemplar {
    return new Exemplar().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Exemplar {
    return new Exemplar().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Exemplar {
    return new Exemplar().fromJsonString(jsonString, options);
  }

  static equals(a: Exemplar | PlainMessage<Exemplar> | undefined, b: Exemplar | PlainMessage<Exemplar> | undefined): boolean {
    return proto3.util.equals(Exemplar, a, b);
  }
}

