// @generated
// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AwsiamAuthDatabaseConnector {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub database: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Any {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Array {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, boxed, tag="2")]
    pub element: ::core::option::Option<::prost::alloc::boxed::Box<Type>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bool {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bytes {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Config {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub r#type: ::core::option::Option<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsnDatabaseConnector {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub dsn: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Data {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="5")]
    pub type_parameters: ::prost::alloc::vec::Vec<TypeParameter>,
    #[prost(message, repeated, tag="6")]
    pub fields: ::prost::alloc::vec::Vec<Field>,
    #[prost(message, repeated, tag="7")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Database {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag="31634")]
    pub runtime: ::core::option::Option<DatabaseRuntime>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="4")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="5")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseConnector {
    #[prost(oneof="database_connector::Value", tags="2, 1")]
    pub value: ::core::option::Option<database_connector::Value>,
}
/// Nested message and enum types in `DatabaseConnector`.
pub mod database_connector {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="2")]
        AwsiamAuthDatabaseConnector(super::AwsiamAuthDatabaseConnector),
        #[prost(message, tag="1")]
        DsnDatabaseConnector(super::DsnDatabaseConnector),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseRuntime {
    #[prost(message, optional, tag="1")]
    pub connections: ::core::option::Option<DatabaseRuntimeConnections>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseRuntimeConnections {
    #[prost(message, optional, tag="1")]
    pub read: ::core::option::Option<DatabaseConnector>,
    #[prost(message, optional, tag="2")]
    pub write: ::core::option::Option<DatabaseConnector>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseRuntimeConnectionsEvent {
    #[prost(message, optional, tag="1")]
    pub connections: ::core::option::Option<DatabaseRuntimeConnections>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseRuntimeEvent {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub payload: ::core::option::Option<DatabaseRuntimeEventPayload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseRuntimeEventPayload {
    #[prost(oneof="database_runtime_event_payload::Value", tags="1")]
    pub value: ::core::option::Option<database_runtime_event_payload::Value>,
}
/// Nested message and enum types in `DatabaseRuntimeEventPayload`.
pub mod database_runtime_event_payload {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="1")]
        DatabaseRuntimeConnectionsEvent(super::DatabaseRuntimeConnectionsEvent),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Decl {
    #[prost(oneof="decl::Value", tags="6, 1, 3, 4, 7, 9, 5, 2")]
    pub value: ::core::option::Option<decl::Value>,
}
/// Nested message and enum types in `Decl`.
pub mod decl {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="6")]
        Config(super::Config),
        #[prost(message, tag="1")]
        Data(super::Data),
        #[prost(message, tag="3")]
        Database(super::Database),
        #[prost(message, tag="4")]
        Enum(super::Enum),
        #[prost(message, tag="7")]
        Secret(super::Secret),
        #[prost(message, tag="9")]
        Topic(super::Topic),
        #[prost(message, tag="5")]
        TypeAlias(super::TypeAlias),
        #[prost(message, tag="2")]
        Verb(super::Verb),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Enum {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub r#type: ::core::option::Option<Type>,
    #[prost(message, repeated, tag="6")]
    pub variants: ::prost::alloc::vec::Vec<EnumVariant>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumVariant {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub value: ::core::option::Option<Value>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Field {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="3")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub r#type: ::core::option::Option<Type>,
    #[prost(message, repeated, tag="5")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Float {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngressPathComponent {
    #[prost(oneof="ingress_path_component::Value", tags="1, 2")]
    pub value: ::core::option::Option<ingress_path_component::Value>,
}
/// Nested message and enum types in `IngressPathComponent`.
pub mod ingress_path_component {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="1")]
        IngressPathLiteral(super::IngressPathLiteral),
        #[prost(message, tag="2")]
        IngressPathParameter(super::IngressPathParameter),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngressPathLiteral {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngressPathParameter {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Int {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntValue {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(int64, tag="2")]
    pub value: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Map {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, boxed, tag="2")]
    pub key: ::core::option::Option<::prost::alloc::boxed::Box<Type>>,
    #[prost(message, optional, boxed, tag="3")]
    pub value: ::core::option::Option<::prost::alloc::boxed::Box<Type>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(oneof="metadata::Value", tags="5, 14, 1, 10, 3, 4, 9, 2, 12, 6, 13, 11, 7, 8")]
    pub value: ::core::option::Option<metadata::Value>,
}
/// Nested message and enum types in `Metadata`.
pub mod metadata {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="5")]
        Alias(super::MetadataAlias),
        #[prost(message, tag="14")]
        Artefact(super::MetadataArtefact),
        #[prost(message, tag="1")]
        Calls(super::MetadataCalls),
        #[prost(message, tag="10")]
        Config(super::MetadataConfig),
        #[prost(message, tag="3")]
        CronJob(super::MetadataCronJob),
        #[prost(message, tag="4")]
        Databases(super::MetadataDatabases),
        #[prost(message, tag="9")]
        Encoding(super::MetadataEncoding),
        #[prost(message, tag="2")]
        Ingress(super::MetadataIngress),
        #[prost(message, tag="12")]
        Publisher(super::MetadataPublisher),
        #[prost(message, tag="6")]
        Retry(super::MetadataRetry),
        #[prost(message, tag="13")]
        SqlMigration(super::MetadataSqlMigration),
        #[prost(message, tag="11")]
        Secrets(super::MetadataSecrets),
        #[prost(message, tag="7")]
        Subscriber(super::MetadataSubscriber),
        #[prost(message, tag="8")]
        TypeMap(super::MetadataTypeMap),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataAlias {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(enumeration="AliasKind", tag="2")]
    pub kind: i32,
    #[prost(string, tag="3")]
    pub alias: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataArtefact {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub digest: ::prost::alloc::string::String,
    #[prost(bool, tag="4")]
    pub executable: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataCalls {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub calls: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataConfig {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub config: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataCronJob {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub cron: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataDatabases {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub calls: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataEncoding {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(bool, tag="3")]
    pub lenient: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataIngress {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub method: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub path: ::prost::alloc::vec::Vec<IngressPathComponent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataPublisher {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub topics: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataRetry {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(int64, optional, tag="2")]
    pub count: ::core::option::Option<i64>,
    #[prost(string, tag="3")]
    pub min_backoff: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub max_backoff: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub catch: ::core::option::Option<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataSqlMigration {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub digest: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataSecrets {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub secrets: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataSubscriber {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag="2")]
    pub topic: ::core::option::Option<Ref>,
    #[prost(enumeration="FromOffset", tag="3")]
    pub from_offset: i32,
    #[prost(bool, tag="4")]
    pub dead_letter: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataTypeMap {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub runtime: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub native_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Module {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub builtin: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="6")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
    #[prost(message, repeated, tag="5")]
    pub decls: ::prost::alloc::vec::Vec<Decl>,
    #[prost(message, optional, tag="31634")]
    pub runtime: ::core::option::Option<ModuleRuntime>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleRuntime {
    #[prost(message, optional, tag="1")]
    pub base: ::core::option::Option<ModuleRuntimeBase>,
    #[prost(message, optional, tag="2")]
    pub scaling: ::core::option::Option<ModuleRuntimeScaling>,
    #[prost(message, optional, tag="3")]
    pub deployment: ::core::option::Option<ModuleRuntimeDeployment>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleRuntimeBase {
    #[prost(message, optional, tag="1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag="2")]
    pub language: ::prost::alloc::string::String,
    #[prost(string, optional, tag="3")]
    pub os: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub arch: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="5")]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleRuntimeDeployment {
    #[prost(string, tag="1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub deployment_key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleRuntimeEvent {
    #[prost(oneof="module_runtime_event::Value", tags="1, 3, 2")]
    pub value: ::core::option::Option<module_runtime_event::Value>,
}
/// Nested message and enum types in `ModuleRuntimeEvent`.
pub mod module_runtime_event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="1")]
        ModuleRuntimeBase(super::ModuleRuntimeBase),
        #[prost(message, tag="3")]
        ModuleRuntimeDeployment(super::ModuleRuntimeDeployment),
        #[prost(message, tag="2")]
        ModuleRuntimeScaling(super::ModuleRuntimeScaling),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModuleRuntimeScaling {
    #[prost(int32, tag="1")]
    pub min_replicas: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Optional {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, boxed, tag="2")]
    pub r#type: ::core::option::Option<::prost::alloc::boxed::Box<Type>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Position {
    #[prost(string, tag="1")]
    pub filename: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub line: i64,
    #[prost(int64, tag="3")]
    pub column: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ref {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="3")]
    pub module: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub type_parameters: ::prost::alloc::vec::Vec<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeEvent {
    #[prost(oneof="runtime_event::Value", tags="5, 1, 3, 2, 6, 4")]
    pub value: ::core::option::Option<runtime_event::Value>,
}
/// Nested message and enum types in `RuntimeEvent`.
pub mod runtime_event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="5")]
        DatabaseRuntimeEvent(super::DatabaseRuntimeEvent),
        #[prost(message, tag="1")]
        ModuleRuntimeBase(super::ModuleRuntimeBase),
        #[prost(message, tag="3")]
        ModuleRuntimeDeployment(super::ModuleRuntimeDeployment),
        #[prost(message, tag="2")]
        ModuleRuntimeScaling(super::ModuleRuntimeScaling),
        #[prost(message, tag="6")]
        TopicRuntimeEvent(super::TopicRuntimeEvent),
        #[prost(message, tag="4")]
        VerbRuntimeEvent(super::VerbRuntimeEvent),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub modules: ::prost::alloc::vec::Vec<Module>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Secret {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub r#type: ::core::option::Option<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct String {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringValue {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Time {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Topic {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag="31634")]
    pub runtime: ::core::option::Option<TopicRuntime>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub event: ::core::option::Option<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicRuntime {
    #[prost(string, repeated, tag="1")]
    pub kafka_brokers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="2")]
    pub topic_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicRuntimeEvent {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub payload: ::core::option::Option<TopicRuntime>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Type {
    #[prost(oneof="r#type::Value", tags="9, 7, 5, 4, 2, 1, 8, 12, 11, 3, 6, 10")]
    pub value: ::core::option::Option<r#type::Value>,
}
/// Nested message and enum types in `Type`.
pub mod r#type {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="9")]
        Any(super::Any),
        #[prost(message, tag="7")]
        Array(::prost::alloc::boxed::Box<super::Array>),
        #[prost(message, tag="5")]
        Bool(super::Bool),
        #[prost(message, tag="4")]
        Bytes(super::Bytes),
        #[prost(message, tag="2")]
        Float(super::Float),
        #[prost(message, tag="1")]
        Int(super::Int),
        #[prost(message, tag="8")]
        Map(::prost::alloc::boxed::Box<super::Map>),
        #[prost(message, tag="12")]
        Optional(::prost::alloc::boxed::Box<super::Optional>),
        #[prost(message, tag="11")]
        Ref(super::Ref),
        #[prost(message, tag="3")]
        String(super::String),
        #[prost(message, tag="6")]
        Time(super::Time),
        #[prost(message, tag="10")]
        Unit(super::Unit),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeAlias {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub r#type: ::core::option::Option<Type>,
    #[prost(message, repeated, tag="6")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeParameter {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeValue {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag="2")]
    pub value: ::core::option::Option<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Unit {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof="value::Value", tags="2, 1, 3")]
    pub value: ::core::option::Option<value::Value>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="2")]
        IntValue(super::IntValue),
        #[prost(message, tag="1")]
        StringValue(super::StringValue),
        #[prost(message, tag="3")]
        TypeValue(super::TypeValue),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Verb {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub request: ::core::option::Option<Type>,
    #[prost(message, optional, tag="6")]
    pub response: ::core::option::Option<Type>,
    #[prost(message, repeated, tag="7")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
    #[prost(message, optional, tag="31634")]
    pub runtime: ::core::option::Option<VerbRuntime>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbRuntime {
    #[prost(message, optional, tag="1")]
    pub base: ::core::option::Option<VerbRuntimeBase>,
    #[prost(message, optional, tag="2")]
    pub subscription: ::core::option::Option<VerbRuntimeSubscription>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VerbRuntimeBase {
    #[prost(message, optional, tag="1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="2")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbRuntimeEvent {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub payload: ::core::option::Option<VerbRuntimePayload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbRuntimePayload {
    #[prost(oneof="verb_runtime_payload::Value", tags="1, 2")]
    pub value: ::core::option::Option<verb_runtime_payload::Value>,
}
/// Nested message and enum types in `VerbRuntimePayload`.
pub mod verb_runtime_payload {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="1")]
        VerbRuntimeBase(super::VerbRuntimeBase),
        #[prost(message, tag="2")]
        VerbRuntimeSubscription(super::VerbRuntimeSubscription),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbRuntimeSubscription {
    #[prost(string, repeated, tag="1")]
    pub kafka_brokers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AliasKind {
    Unspecified = 0,
    Json = 1,
}
impl AliasKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ALIAS_KIND_UNSPECIFIED",
            Self::Json => "ALIAS_KIND_JSON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALIAS_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "ALIAS_KIND_JSON" => Some(Self::Json),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FromOffset {
    Unspecified = 0,
    Beginning = 1,
    Latest = 2,
}
impl FromOffset {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FROM_OFFSET_UNSPECIFIED",
            Self::Beginning => "FROM_OFFSET_BEGINNING",
            Self::Latest => "FROM_OFFSET_LATEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FROM_OFFSET_UNSPECIFIED" => Some(Self::Unspecified),
            "FROM_OFFSET_BEGINNING" => Some(Self::Beginning),
            "FROM_OFFSET_LATEST" => Some(Self::Latest),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
