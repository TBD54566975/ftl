// @generated
// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Any {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Array {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, boxed, tag="2")]
    pub element: ::core::option::Option<::prost::alloc::boxed::Box<Type>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bool {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bytes {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Config {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub r#type: ::core::option::Option<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Data {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="5")]
    pub type_parameters: ::prost::alloc::vec::Vec<TypeParameter>,
    #[prost(message, repeated, tag="6")]
    pub fields: ::prost::alloc::vec::Vec<Field>,
    #[prost(message, repeated, tag="7")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Database {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag="31634")]
    pub runtime: ::core::option::Option<DatabaseRuntime>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="4")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseRuntime {
    #[prost(string, tag="1")]
    pub dsn: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Decl {
    #[prost(oneof="decl::Value", tags="6, 1, 3, 4, 7, 10, 9, 5, 2")]
    pub value: ::core::option::Option<decl::Value>,
}
/// Nested message and enum types in `Decl`.
pub mod decl {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="6")]
        Config(super::Config),
        #[prost(message, tag="1")]
        Data(super::Data),
        #[prost(message, tag="3")]
        Database(super::Database),
        #[prost(message, tag="4")]
        Enum(super::Enum),
        #[prost(message, tag="7")]
        Secret(super::Secret),
        #[prost(message, tag="10")]
        Subscription(super::Subscription),
        #[prost(message, tag="9")]
        Topic(super::Topic),
        #[prost(message, tag="5")]
        TypeAlias(super::TypeAlias),
        #[prost(message, tag="2")]
        Verb(super::Verb),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Enum {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub r#type: ::core::option::Option<Type>,
    #[prost(message, repeated, tag="6")]
    pub variants: ::prost::alloc::vec::Vec<EnumVariant>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumVariant {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub value: ::core::option::Option<Value>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Field {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="3")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub r#type: ::core::option::Option<Type>,
    #[prost(message, repeated, tag="5")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Float {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngressPathComponent {
    #[prost(oneof="ingress_path_component::Value", tags="1, 2")]
    pub value: ::core::option::Option<ingress_path_component::Value>,
}
/// Nested message and enum types in `IngressPathComponent`.
pub mod ingress_path_component {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="1")]
        IngressPathLiteral(super::IngressPathLiteral),
        #[prost(message, tag="2")]
        IngressPathParameter(super::IngressPathParameter),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngressPathLiteral {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngressPathParameter {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Int {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntValue {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(int64, tag="2")]
    pub value: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Map {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, boxed, tag="2")]
    pub key: ::core::option::Option<::prost::alloc::boxed::Box<Type>>,
    #[prost(message, optional, boxed, tag="3")]
    pub value: ::core::option::Option<::prost::alloc::boxed::Box<Type>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(oneof="metadata::Value", tags="5, 1, 10, 3, 4, 9, 2, 12, 6, 11, 7, 8")]
    pub value: ::core::option::Option<metadata::Value>,
}
/// Nested message and enum types in `Metadata`.
pub mod metadata {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="5")]
        Alias(super::MetadataAlias),
        #[prost(message, tag="1")]
        Calls(super::MetadataCalls),
        #[prost(message, tag="10")]
        Config(super::MetadataConfig),
        #[prost(message, tag="3")]
        CronJob(super::MetadataCronJob),
        #[prost(message, tag="4")]
        Databases(super::MetadataDatabases),
        #[prost(message, tag="9")]
        Encoding(super::MetadataEncoding),
        #[prost(message, tag="2")]
        Ingress(super::MetadataIngress),
        #[prost(message, tag="12")]
        Publisher(super::MetadataPublisher),
        #[prost(message, tag="6")]
        Retry(super::MetadataRetry),
        #[prost(message, tag="11")]
        Secrets(super::MetadataSecrets),
        #[prost(message, tag="7")]
        Subscriber(super::MetadataSubscriber),
        #[prost(message, tag="8")]
        TypeMap(super::MetadataTypeMap),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataAlias {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(enumeration="AliasKind", tag="2")]
    pub kind: i32,
    #[prost(string, tag="3")]
    pub alias: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataCalls {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub calls: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataConfig {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub config: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataCronJob {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub cron: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataDatabases {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub calls: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataEncoding {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(bool, tag="3")]
    pub lenient: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataIngress {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub method: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub path: ::prost::alloc::vec::Vec<IngressPathComponent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataPublisher {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub topics: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataRetry {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(int64, optional, tag="2")]
    pub count: ::core::option::Option<i64>,
    #[prost(string, tag="3")]
    pub min_backoff: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub max_backoff: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub catch: ::core::option::Option<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataSecrets {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub secrets: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataSubscriber {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataTypeMap {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub runtime: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub native_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Module {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub builtin: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="5")]
    pub decls: ::prost::alloc::vec::Vec<Decl>,
    #[prost(message, optional, tag="31634")]
    pub runtime: ::core::option::Option<ModuleRuntime>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleRuntime {
    #[prost(message, optional, tag="1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag="2")]
    pub language: ::prost::alloc::string::String,
    #[prost(int32, tag="3")]
    pub min_replicas: i32,
    #[prost(string, optional, tag="4")]
    pub os: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="5")]
    pub arch: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="6")]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Optional {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, boxed, tag="2")]
    pub r#type: ::core::option::Option<::prost::alloc::boxed::Box<Type>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Position {
    #[prost(string, tag="1")]
    pub filename: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub line: i64,
    #[prost(int64, tag="3")]
    pub column: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ref {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="3")]
    pub module: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub type_parameters: ::prost::alloc::vec::Vec<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub modules: ::prost::alloc::vec::Vec<Module>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Secret {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub r#type: ::core::option::Option<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct String {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringValue {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subscription {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub topic: ::core::option::Option<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Time {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Topic {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub event: ::core::option::Option<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Type {
    #[prost(oneof="r#type::Value", tags="9, 7, 5, 4, 2, 1, 8, 12, 11, 3, 6, 10")]
    pub value: ::core::option::Option<r#type::Value>,
}
/// Nested message and enum types in `Type`.
pub mod r#type {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="9")]
        Any(super::Any),
        #[prost(message, tag="7")]
        Array(::prost::alloc::boxed::Box<super::Array>),
        #[prost(message, tag="5")]
        Bool(super::Bool),
        #[prost(message, tag="4")]
        Bytes(super::Bytes),
        #[prost(message, tag="2")]
        Float(super::Float),
        #[prost(message, tag="1")]
        Int(super::Int),
        #[prost(message, tag="8")]
        Map(::prost::alloc::boxed::Box<super::Map>),
        #[prost(message, tag="12")]
        Optional(::prost::alloc::boxed::Box<super::Optional>),
        #[prost(message, tag="11")]
        Ref(super::Ref),
        #[prost(message, tag="3")]
        String(super::String),
        #[prost(message, tag="6")]
        Time(super::Time),
        #[prost(message, tag="10")]
        Unit(super::Unit),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeAlias {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub r#type: ::core::option::Option<Type>,
    #[prost(message, repeated, tag="6")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeParameter {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeValue {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag="2")]
    pub value: ::core::option::Option<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Unit {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof="value::Value", tags="2, 1, 3")]
    pub value: ::core::option::Option<value::Value>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="2")]
        IntValue(super::IntValue),
        #[prost(message, tag="1")]
        StringValue(super::StringValue),
        #[prost(message, tag="3")]
        TypeValue(super::TypeValue),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Verb {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub request: ::core::option::Option<Type>,
    #[prost(message, optional, tag="6")]
    pub response: ::core::option::Option<Type>,
    #[prost(message, repeated, tag="7")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
    #[prost(message, optional, tag="31634")]
    pub runtime: ::core::option::Option<VerbRuntime>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VerbRuntime {
    #[prost(message, optional, tag="1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="2")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AliasKind {
    Json = 0,
}
impl AliasKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Json => "ALIAS_KIND_JSON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALIAS_KIND_JSON" => Some(Self::Json),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
