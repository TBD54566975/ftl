//! A crate for parsing/generating code to and from schema binary.
use prost::Message;
use syn::Path;

pub mod proto {
    // tonic::include_proto!("xyz.block.ftl.v1.schema");
    // Generated by [`prost-build`]
    include!(concat!(env!("OUT_DIR"), "/xyz.block.ftl.v1.schema.rs"));
    // Generated by [`pbjson-build`]
    include!(concat!(
        env!("OUT_DIR"),
        "/xyz.block.ftl.v1.schema.serde.rs"
    ));
}

pub struct Context {
    // TODO
}

pub fn module_from_binary(mut reader: impl std::io::Read) -> proto::Module {
    let mut buf = Vec::new();
    reader.read_to_end(&mut buf).unwrap();
    proto::Module::decode(&buf[..]).unwrap()
}

pub fn parse(code: &str) -> proto::Module {
    let ast = syn::parse_file(code).unwrap();
    let verbs = extract_verbs(ast);
    verbs.iter().for_each(|verb| {
        let has_ctx = has_context_as_first_arg(verb);
        if !has_ctx {
            panic!("First argument must be of type Context");
        }
    });

    todo!()
}

// Extract functions that are annotated with #[ftl::verb] and extract the function signature.
fn extract_verbs(ast: syn::File) -> Vec<syn::ItemFn> {
    let ftl_verb_path = syn::parse_str("ftl::verb").unwrap();

    ast.items
        .iter()
        .filter_map(|item| {
            let syn::Item::Fn(func) = item else {
                return None;
            };

            return if has_meta_path(&func.attrs, &ftl_verb_path) {
                Some(func.clone())
            } else {
                None
            };
        })
        .collect()
}

// Look for #[path_str] e.g. #[ftl::verb], and extract the function signature.
fn has_meta_path(attrs: &[syn::Attribute], expected_path: &Path) -> bool {
    attrs.iter().any(|attr| attr.meta.path() == expected_path)
}

fn has_context_as_first_arg(func: &syn::ItemFn) -> bool {
    let Some(arg) = func.sig.inputs.first() else {
        println!("Function must have at least one argument");
        return false;
    };

    let syn::FnArg::Typed(pat) = arg else {
        println!("First argument must not be a self argument");
        return false;
    };

    let syn::Type::Reference(path) = &*pat.ty else {
        println!(
            "First argument must be of type Reference instead of {:?}",
            pat.ty
        );
        return false;
    };
    let syn::Type::Path(type_path) = &*path.elem else {
        println!(
            "First argument must be of type Path instead of {:?}",
            path.elem
        );
        return false;
    };

    let context_path = syn::parse_str("Context").unwrap();
    if type_path.path != context_path {
        println!(
            "First argument must be of type Context instead of {:?}",
            type_path.path
        );
        return false;
    }

    true
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let config = proto::Config {
            pos: None,
            comments: vec![],
            name: "sup".to_string(),
            r#type: None,
        };

        let mut encoded = Vec::new();
        Message::encode(&config, &mut encoded).unwrap();

        let decoded = proto::Config::decode(&encoded[..]).unwrap();
        assert_eq!(config, decoded);

        dbg!(encoded);
        dbg!(decoded);
    }

    #[test]
    fn ast_to_proto() {
        //
        let code = r#"
        struct Request {
            pub name: String,
            pub age: u32,
        }

        #[ftl::verb]
        pub async fn test_verb(ctx: &Context, request: Request) -> Result<String, Error> {
            let response = ctx.call("module::other_verb", request).await?;

            #[ftl::call]
            let response = module::other_verb(request).await?;

            Ok("Hello, World!".to_string())
        }
        "#;

        let m = parse(code);

        dbg!(m);
    }
}
