// Code generated by go2proto. DO NOT EDIT.

package testdata

import "fmt"
import destpb "github.com/TBD54566975/ftl/cmd/go2proto/testdata/testdatapb"
import "google.golang.org/protobuf/proto"
import "google.golang.org/protobuf/types/known/timestamppb"
import "google.golang.org/protobuf/types/known/durationpb"

var _ fmt.Stringer
var _ = timestamppb.Timestamp{}
var _ = durationpb.Duration{}

// protoSlice converts a slice of values to a slice of protobuf values.
func protoSlice[P any, T interface{ ToProto() P }](values []T) []P {
	out := make([]P, len(values))
	for i, v := range values {
		out[i] = v.ToProto()
	}
	return out
}

// protoSlicef converts a slice of values to a slice of protobuf values using a mapping function.
func protoSlicef[P, T any](values []T, f func(T) P) []P {
	out := make([]P, len(values))
	for i, v := range values {
		out[i] = f(v)
	}
	return out
}

func protoMust[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func (x Enum) ToProto() destpb.Enum {
	return destpb.Enum(x)
}

func (x *Message) ToProto() *destpb.Message {
	if x == nil {
		return nil
	}
	return &destpb.Message{
		Time:     string(protoMust(x.Time.MarshalText())),
		Duration: durationpb.New(x.Duration),
		Nested:   x.Nested.ToProto(),
	}
}

func (x *Nested) ToProto() *destpb.Nested {
	if x == nil {
		return nil
	}
	return &destpb.Nested{
		Nested: string(x.Nested),
	}
}

func (x *Root) ToProto() *destpb.Root {
	if x == nil {
		return nil
	}
	return &destpb.Root{
		Int:            int64(x.Int),
		String_:        string(x.String),
		MessagePtr:     x.MessagePtr.ToProto(),
		Enum:           x.Enum.ToProto(),
		SumType:        SumTypeToProto(x.SumType),
		OptionalInt:    proto.Int64(int64(x.OptionalInt)),
		OptionalIntPtr: proto.Int64(int64(*x.OptionalIntPtr)),
		OptionalMsg:    x.OptionalMsg.ToProto(),
		RepeatedInt:    protoSlicef(x.RepeatedInt, func(v int) int64 { return int64(v) }),
		RepeatedMsg:    protoSlice[*destpb.Message](x.RepeatedMsg),
		Url:            protoMust(x.URL.MarshalBinary()),
		Key:            string(protoMust(x.Key.MarshalText())),
	}
}

// SubSumTypeToProto converts a SubSumType sum type to a protobuf message.
func SubSumTypeToProto(value SubSumType) *destpb.SubSumType {
	switch value := value.(type) {
	case nil:
		return nil
	case *SubSumTypeA:
		return &destpb.SubSumType{
			Value: &destpb.SubSumType_A{value.ToProto()},
		}
	case *SubSumTypeB:
		return &destpb.SubSumType{
			Value: &destpb.SubSumType_B{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func (x *SubSumTypeA) ToProto() *destpb.SubSumTypeA {
	if x == nil {
		return nil
	}
	return &destpb.SubSumTypeA{
		A: string(x.A),
	}
}

func (x *SubSumTypeB) ToProto() *destpb.SubSumTypeB {
	if x == nil {
		return nil
	}
	return &destpb.SubSumTypeB{
		A: string(x.A),
	}
}

// SumTypeToProto converts a SumType sum type to a protobuf message.
func SumTypeToProto(value SumType) *destpb.SumType {
	switch value := value.(type) {
	case nil:
		return nil
	case *SubSumTypeA:
		return &destpb.SumType{
			Value: &destpb.SumType_SubSumTypeA{value.ToProto()},
		}
	case *SubSumTypeB:
		return &destpb.SumType{
			Value: &destpb.SumType_SubSumTypeB{value.ToProto()},
		}
	case *SumTypeA:
		return &destpb.SumType{
			Value: &destpb.SumType_A{value.ToProto()},
		}
	case *SumTypeB:
		return &destpb.SumType{
			Value: &destpb.SumType_B{value.ToProto()},
		}
	case *SumTypeC:
		return &destpb.SumType{
			Value: &destpb.SumType_C{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func (x *SumTypeA) ToProto() *destpb.SumTypeA {
	if x == nil {
		return nil
	}
	return &destpb.SumTypeA{
		A: string(x.A),
	}
}

func (x *SumTypeB) ToProto() *destpb.SumTypeB {
	if x == nil {
		return nil
	}
	return &destpb.SumTypeB{
		B: int64(x.B),
	}
}

func (x *SumTypeC) ToProto() *destpb.SumTypeC {
	if x == nil {
		return nil
	}
	return &destpb.SumTypeC{
		C: float64(x.C),
	}
}
