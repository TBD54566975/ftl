package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

type hover struct {
	// Match this text for triggering this hover, e.g. "//ftl:typealias"
	Match string `json:"match"`

	// Source file to read from.
	Source string `json:"source"`

	// Select these heading to use for the docs. If omitted, the entire markdown file is used.
	// Headings are included in the output.
	Select []string `json:"select,omitempty"`
}

func main() {
	hovers := parseHover()
	collected := make(map[string]string, len(hovers))

	for _, hover := range hovers {
		path := filepath.Join("docs", "content", "docs", hover.Source)
		file, err := os.Open(path)
		if err != nil {
			panic(err)
		}

		content, title := getMarkdownWithTitle(file)

		if len(hover.Select) > 0 {
			output := ""
			for _, sel := range hover.Select {
				output += selector(content, sel)
			}
			content = output
		} else {
			// We need to inject a heading for the hover content.
			content = fmt.Sprintf("## %s\n\n%s", title, content)
		}

		collected[hover.Match] = content
	}

	writeGoFile(collected)
}

func parseHover() []hover {
	path := "lsp/hover.json"

	file, err := os.Open(path)
	if err != nil {
		panic(err)
	}

	var hovers []hover
	err = json.NewDecoder(file).Decode(&hovers)
	if err != nil {
		panic(err)
	}

	return hovers
}

func getMarkdownWithTitle(file *os.File) (string, string) {
	content, err := io.ReadAll(file)
	if err != nil {
		panic(err)
	}

	// Zola markdown files have a +++ delimiter. An initial one, then metadata, then markdown content.
	parts := bytes.Split(content, []byte("+++"))
	if len(parts) < 3 {
		panic(fmt.Sprintf("file %s does not contain two +++ strings", file.Name()))
	}

	// Look for the title in the metadata.
	// title = "PubSub"
	var title string
	lines := strings.Split(string(parts[1]), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "title = ") {
			title = strings.TrimSpace(strings.TrimPrefix(line, "title = "))
			title = strings.Trim(title, "\"")
			break
		}
	}
	if title == "" {
		panic(fmt.Sprintf("file %s does not contain a title", file.Name()))
	}

	return string(parts[2]), title
}

func selector(content, selector string) string {
	// Split the content into lines.
	lines := strings.Split(content, "\n")
	collected := []string{}

	// If the selector starts with ## (the only type of heading we have):
	// Find the line, include it, and all lines until the next heading.
	if strings.HasPrefix(selector, "##") {
		include := false
		for _, line := range lines {
			if include {
				if strings.HasPrefix(line, "##") {
					break
				}

				// We also stop at a line break, because we don't want to include footnotes.
				// See the end of docs/content/docs/reference/types.md for an example.
				if line == "---" {
					break
				}

				collected = append(collected, line)
			}

			// Start collecting
			if strings.HasPrefix(line, selector) {
				include = true
				collected = append(collected, line)
			}
		}
	} else {
		panic(fmt.Sprintf("unsupported selector %s", selector))
	}

	if len(collected) == 0 {
		panic(fmt.Sprintf("no content found for selector %s", selector))
	}

	return strings.TrimSpace(strings.Join(collected, "\n")) + "\n"
}

func writeGoFile(collected map[string]string) {
	path := "lsp/hoveritems.go"
	file, err := os.Create(path)
	if err != nil {
		panic(err)
	}
	defer file.Close()
	p := panicWriter(*file)

	p.Write("// Code generated by ftl-lsp-gen. DO NOT EDIT.")
	p.Write("package lsp")
	p.Write("")
	p.Write("var hoverMap = map[string]string{")
	for match, content := range collected {
		p.Write(fmt.Sprintf("\t%q: %q,", match, content))
	}
	p.Write("}")

	fmt.Printf("Generated %s\n", path)
}

type panicWriter os.File

func (w *panicWriter) Write(p string) {
	f := (*os.File)(w)
	_, err := f.WriteString(fmt.Sprintf("%s\n", p))
	if err != nil {
		panic(err)
	}
}
