// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: xyz/block/ftl/v1/ftl.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Xyz_Block_Ftl_V1_DeploymentChangeType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case deploymentAdded // = 0
  case deploymentRemoved // = 1
  case deploymentChanged // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .deploymentAdded
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .deploymentAdded
    case 1: self = .deploymentRemoved
    case 2: self = .deploymentChanged
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .deploymentAdded: return 0
    case .deploymentRemoved: return 1
    case .deploymentChanged: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Xyz_Block_Ftl_V1_DeploymentChangeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Xyz_Block_Ftl_V1_DeploymentChangeType] = [
    .deploymentAdded,
    .deploymentRemoved,
    .deploymentChanged,
  ]
}

#endif  // swift(>=4.2)

public enum Xyz_Block_Ftl_V1_RunnerState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The Runner is waiting for a deployment.
  case runnerIdle // = 0

  /// The Runner and Controller have agreed that the Runner is reserved.
  case runnerReserved // = 1

  /// The Runner is assigned to a deployment.
  case runnerAssigned // = 2

  /// The Runner is dead.
  case runnerDead // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .runnerIdle
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .runnerIdle
    case 1: self = .runnerReserved
    case 2: self = .runnerAssigned
    case 3: self = .runnerDead
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .runnerIdle: return 0
    case .runnerReserved: return 1
    case .runnerAssigned: return 2
    case .runnerDead: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Xyz_Block_Ftl_V1_RunnerState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Xyz_Block_Ftl_V1_RunnerState] = [
    .runnerIdle,
    .runnerReserved,
    .runnerAssigned,
    .runnerDead,
  ]
}

#endif  // swift(>=4.2)

public enum Xyz_Block_Ftl_V1_ConfigProvider: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Write values inline in the configuration file.
  case configInline // = 0

  /// Print configuration as environment variables.
  case configEnvar // = 1

  /// Use the database as a configuration store.
  case configDb // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .configInline
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .configInline
    case 1: self = .configEnvar
    case 2: self = .configDb
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .configInline: return 0
    case .configEnvar: return 1
    case .configDb: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Xyz_Block_Ftl_V1_ConfigProvider: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Xyz_Block_Ftl_V1_ConfigProvider] = [
    .configInline,
    .configEnvar,
    .configDb,
  ]
}

#endif  // swift(>=4.2)

public enum Xyz_Block_Ftl_V1_SecretProvider: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Write values inline in the configuration file.
  case secretInline // = 0

  /// Print configuration as environment variables.
  case secretEnvar // = 1

  /// Write to the system keychain.
  case secretKeychain // = 2

  /// Store a secret in the 1Password vault.
  case secretOp // = 3

  /// Store a secret in the AWS Secrets Manager.
  case secretAsm // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .secretInline
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .secretInline
    case 1: self = .secretEnvar
    case 2: self = .secretKeychain
    case 3: self = .secretOp
    case 4: self = .secretAsm
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .secretInline: return 0
    case .secretEnvar: return 1
    case .secretKeychain: return 2
    case .secretOp: return 3
    case .secretAsm: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Xyz_Block_Ftl_V1_SecretProvider: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Xyz_Block_Ftl_V1_SecretProvider] = [
    .secretInline,
    .secretEnvar,
    .secretKeychain,
    .secretOp,
    .secretAsm,
  ]
}

#endif  // swift(>=4.2)

public struct Xyz_Block_Ftl_V1_PingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_PingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If present, the service is not ready to accept requests and this is the
  /// reason.
  public var notReady: String {
    get {return _notReady ?? String()}
    set {_notReady = newValue}
  }
  /// Returns true if `notReady` has been explicitly set.
  public var hasNotReady: Bool {return self._notReady != nil}
  /// Clears the value of `notReady`. Subsequent reads from it will return its default value.
  public mutating func clearNotReady() {self._notReady = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _notReady: String? = nil
}

public struct Xyz_Block_Ftl_V1_ModuleContextRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var module: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_ModuleContextResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var module: String = String()

  public var configs: Dictionary<String,Data> = [:]

  public var secrets: Dictionary<String,Data> = [:]

  public var databases: [Xyz_Block_Ftl_V1_ModuleContextResponse.DSN] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum DBType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case postgres // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .postgres
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .postgres
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .postgres: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Ref {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var module: String {
      get {return _module ?? String()}
      set {_module = newValue}
    }
    /// Returns true if `module` has been explicitly set.
    public var hasModule: Bool {return self._module != nil}
    /// Clears the value of `module`. Subsequent reads from it will return its default value.
    public mutating func clearModule() {self._module = nil}

    public var name: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _module: String? = nil
  }

  public struct DSN {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var type: Xyz_Block_Ftl_V1_ModuleContextResponse.DBType = .postgres

    public var dsn: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Xyz_Block_Ftl_V1_ModuleContextResponse.DBType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Xyz_Block_Ftl_V1_ModuleContextResponse.DBType] = [
    .postgres,
  ]
}

#endif  // swift(>=4.2)

public struct Xyz_Block_Ftl_V1_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var values: [Xyz_Block_Ftl_V1_Metadata.Pair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Pair {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String = String()

    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Xyz_Block_Ftl_V1_CallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Xyz_Block_Ftl_V1_Metadata {
    get {return _metadata ?? Xyz_Block_Ftl_V1_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var verb: Xyz_Block_Ftl_V1_Schema_Ref {
    get {return _verb ?? Xyz_Block_Ftl_V1_Schema_Ref()}
    set {_verb = newValue}
  }
  /// Returns true if `verb` has been explicitly set.
  public var hasVerb: Bool {return self._verb != nil}
  /// Clears the value of `verb`. Subsequent reads from it will return its default value.
  public mutating func clearVerb() {self._verb = nil}

  public var body: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Xyz_Block_Ftl_V1_Metadata? = nil
  fileprivate var _verb: Xyz_Block_Ftl_V1_Schema_Ref? = nil
}

public struct Xyz_Block_Ftl_V1_CallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Xyz_Block_Ftl_V1_CallResponse.OneOf_Response? = nil

  public var body: Data {
    get {
      if case .body(let v)? = response {return v}
      return Data()
    }
    set {response = .body(newValue)}
  }

  public var error: Xyz_Block_Ftl_V1_CallResponse.Error {
    get {
      if case .error(let v)? = response {return v}
      return Xyz_Block_Ftl_V1_CallResponse.Error()
    }
    set {response = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case body(Data)
    case error(Xyz_Block_Ftl_V1_CallResponse.Error)

  #if !swift(>=4.1)
    public static func ==(lhs: Xyz_Block_Ftl_V1_CallResponse.OneOf_Response, rhs: Xyz_Block_Ftl_V1_CallResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.body, .body): return {
        guard case .body(let l) = lhs, case .body(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String = String()

    /// TODO: Richer error type.
    public var stack: String {
      get {return _stack ?? String()}
      set {_stack = newValue}
    }
    /// Returns true if `stack` has been explicitly set.
    public var hasStack: Bool {return self._stack != nil}
    /// Clears the value of `stack`. Subsequent reads from it will return its default value.
    public mutating func clearStack() {self._stack = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _stack: String? = nil
  }

  public init() {}
}

public struct Xyz_Block_Ftl_V1_AcquireLeaseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var module: String = String()

  public var key: [String] = []

  public var ttl: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _ttl ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_ttl = newValue}
  }
  /// Returns true if `ttl` has been explicitly set.
  public var hasTtl: Bool {return self._ttl != nil}
  /// Clears the value of `ttl`. Subsequent reads from it will return its default value.
  public mutating func clearTtl() {self._ttl = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ttl: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

public struct Xyz_Block_Ftl_V1_AcquireLeaseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_SendFSMEventRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fsm: Xyz_Block_Ftl_V1_Schema_Ref {
    get {return _fsm ?? Xyz_Block_Ftl_V1_Schema_Ref()}
    set {_fsm = newValue}
  }
  /// Returns true if `fsm` has been explicitly set.
  public var hasFsm: Bool {return self._fsm != nil}
  /// Clears the value of `fsm`. Subsequent reads from it will return its default value.
  public mutating func clearFsm() {self._fsm = nil}

  public var instance: String = String()

  public var event: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _event ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  public var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  public mutating func clearEvent() {self._event = nil}

  public var body: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fsm: Xyz_Block_Ftl_V1_Schema_Ref? = nil
  fileprivate var _event: Xyz_Block_Ftl_V1_Schema_Type? = nil
}

public struct Xyz_Block_Ftl_V1_SendFSMEventResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_PublishEventRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: Xyz_Block_Ftl_V1_Schema_Ref {
    get {return _topic ?? Xyz_Block_Ftl_V1_Schema_Ref()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  public var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  public mutating func clearTopic() {self._topic = nil}

  public var body: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _topic: Xyz_Block_Ftl_V1_Schema_Ref? = nil
}

public struct Xyz_Block_Ftl_V1_PublishEventResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_GetSchemaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_GetSchemaResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var schema: Xyz_Block_Ftl_V1_Schema_Schema {
    get {return _schema ?? Xyz_Block_Ftl_V1_Schema_Schema()}
    set {_schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  public var hasSchema: Bool {return self._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  public mutating func clearSchema() {self._schema = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _schema: Xyz_Block_Ftl_V1_Schema_Schema? = nil
}

public struct Xyz_Block_Ftl_V1_PullSchemaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_PullSchemaResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deploymentKey: String {
    get {return _storage._deploymentKey}
    set {_uniqueStorage()._deploymentKey = newValue}
  }

  public var moduleName: String {
    get {return _storage._moduleName}
    set {_uniqueStorage()._moduleName = newValue}
  }

  /// For deletes this will not be present.
  public var schema: Xyz_Block_Ftl_V1_Schema_Module {
    get {return _storage._schema ?? Xyz_Block_Ftl_V1_Schema_Module()}
    set {_uniqueStorage()._schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  public var hasSchema: Bool {return _storage._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  public mutating func clearSchema() {_uniqueStorage()._schema = nil}

  /// If true there are more schema changes immediately following this one as part of the initial batch.
  /// If false this is the last schema change in the initial batch, but others may follow later.
  public var more: Bool {
    get {return _storage._more}
    set {_uniqueStorage()._more = newValue}
  }

  public var changeType: Xyz_Block_Ftl_V1_DeploymentChangeType {
    get {return _storage._changeType}
    set {_uniqueStorage()._changeType = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Xyz_Block_Ftl_V1_GetArtefactDiffsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clientDigests: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_GetArtefactDiffsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var missingDigests: [String] = []

  /// Artefacts that the client already has, and their path+executable status.
  public var clientArtefacts: [Xyz_Block_Ftl_V1_DeploymentArtefact] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_UploadArtefactRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_UploadArtefactResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var digest: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_DeploymentArtefact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var digest: String = String()

  public var path: String = String()

  public var executable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_CreateDeploymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var schema: Xyz_Block_Ftl_V1_Schema_Module {
    get {return _schema ?? Xyz_Block_Ftl_V1_Schema_Module()}
    set {_schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  public var hasSchema: Bool {return self._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  public mutating func clearSchema() {self._schema = nil}

  public var artefacts: [Xyz_Block_Ftl_V1_DeploymentArtefact] = []

  /// Runner labels required to run this deployment.
  public var labels: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _labels ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_labels = newValue}
  }
  /// Returns true if `labels` has been explicitly set.
  public var hasLabels: Bool {return self._labels != nil}
  /// Clears the value of `labels`. Subsequent reads from it will return its default value.
  public mutating func clearLabels() {self._labels = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _schema: Xyz_Block_Ftl_V1_Schema_Module? = nil
  fileprivate var _labels: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Xyz_Block_Ftl_V1_CreateDeploymentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deploymentKey: String = String()

  /// Currently active deployment for this module, if any.
  public var activeDeploymentKey: String {
    get {return _activeDeploymentKey ?? String()}
    set {_activeDeploymentKey = newValue}
  }
  /// Returns true if `activeDeploymentKey` has been explicitly set.
  public var hasActiveDeploymentKey: Bool {return self._activeDeploymentKey != nil}
  /// Clears the value of `activeDeploymentKey`. Subsequent reads from it will return its default value.
  public mutating func clearActiveDeploymentKey() {self._activeDeploymentKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _activeDeploymentKey: String? = nil
}

public struct Xyz_Block_Ftl_V1_GetDeploymentArtefactsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deploymentKey: String = String()

  public var haveArtefacts: [Xyz_Block_Ftl_V1_DeploymentArtefact] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_GetDeploymentArtefactsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var artefact: Xyz_Block_Ftl_V1_DeploymentArtefact {
    get {return _artefact ?? Xyz_Block_Ftl_V1_DeploymentArtefact()}
    set {_artefact = newValue}
  }
  /// Returns true if `artefact` has been explicitly set.
  public var hasArtefact: Bool {return self._artefact != nil}
  /// Clears the value of `artefact`. Subsequent reads from it will return its default value.
  public mutating func clearArtefact() {self._artefact = nil}

  public var chunk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _artefact: Xyz_Block_Ftl_V1_DeploymentArtefact? = nil
}

public struct Xyz_Block_Ftl_V1_GetDeploymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deploymentKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_GetDeploymentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var schema: Xyz_Block_Ftl_V1_Schema_Module {
    get {return _schema ?? Xyz_Block_Ftl_V1_Schema_Module()}
    set {_schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  public var hasSchema: Bool {return self._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  public mutating func clearSchema() {self._schema = nil}

  public var artefacts: [Xyz_Block_Ftl_V1_DeploymentArtefact] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _schema: Xyz_Block_Ftl_V1_Schema_Module? = nil
}

public struct Xyz_Block_Ftl_V1_RegisterRunnerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var endpoint: String = String()

  public var deployment: String {
    get {return _deployment ?? String()}
    set {_deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  public var hasDeployment: Bool {return self._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  public mutating func clearDeployment() {self._deployment = nil}

  public var state: Xyz_Block_Ftl_V1_RunnerState = .runnerIdle

  public var labels: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _labels ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_labels = newValue}
  }
  /// Returns true if `labels` has been explicitly set.
  public var hasLabels: Bool {return self._labels != nil}
  /// Clears the value of `labels`. Subsequent reads from it will return its default value.
  public mutating func clearLabels() {self._labels = nil}

  /// If present, the reason the Runner is transitioning from ASSIGNED to IDLE.
  public var error: String {
    get {return _error ?? String()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deployment: String? = nil
  fileprivate var _labels: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _error: String? = nil
}

public struct Xyz_Block_Ftl_V1_RegisterRunnerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_UpdateDeployRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deploymentKey: String = String()

  public var minReplicas: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_UpdateDeployResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_ReplaceDeployRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deploymentKey: String = String()

  public var minReplicas: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_ReplaceDeployResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_StreamDeploymentLogsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deploymentKey: String = String()

  public var requestKey: String {
    get {return _requestKey ?? String()}
    set {_requestKey = newValue}
  }
  /// Returns true if `requestKey` has been explicitly set.
  public var hasRequestKey: Bool {return self._requestKey != nil}
  /// Clears the value of `requestKey`. Subsequent reads from it will return its default value.
  public mutating func clearRequestKey() {self._requestKey = nil}

  public var timeStamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timeStamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timeStamp = newValue}
  }
  /// Returns true if `timeStamp` has been explicitly set.
  public var hasTimeStamp: Bool {return self._timeStamp != nil}
  /// Clears the value of `timeStamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimeStamp() {self._timeStamp = nil}

  public var logLevel: Int32 = 0

  public var attributes: Dictionary<String,String> = [:]

  public var message: String = String()

  public var error: String {
    get {return _error ?? String()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestKey: String? = nil
  fileprivate var _timeStamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _error: String? = nil
}

public struct Xyz_Block_Ftl_V1_StreamDeploymentLogsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_StatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_StatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var controllers: [Xyz_Block_Ftl_V1_StatusResponse.Controller] = []

  public var runners: [Xyz_Block_Ftl_V1_StatusResponse.Runner] = []

  public var deployments: [Xyz_Block_Ftl_V1_StatusResponse.Deployment] = []

  public var ingressRoutes: [Xyz_Block_Ftl_V1_StatusResponse.IngressRoute] = []

  public var routes: [Xyz_Block_Ftl_V1_StatusResponse.Route] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Controller {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String = String()

    public var endpoint: String = String()

    public var version: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Runner {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String = String()

    public var languages: [String] = []

    public var endpoint: String = String()

    public var state: Xyz_Block_Ftl_V1_RunnerState = .runnerIdle

    public var deployment: String {
      get {return _deployment ?? String()}
      set {_deployment = newValue}
    }
    /// Returns true if `deployment` has been explicitly set.
    public var hasDeployment: Bool {return self._deployment != nil}
    /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
    public mutating func clearDeployment() {self._deployment = nil}

    public var labels: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _labels ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_labels = newValue}
    }
    /// Returns true if `labels` has been explicitly set.
    public var hasLabels: Bool {return self._labels != nil}
    /// Clears the value of `labels`. Subsequent reads from it will return its default value.
    public mutating func clearLabels() {self._labels = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _deployment: String? = nil
    fileprivate var _labels: SwiftProtobuf.Google_Protobuf_Struct? = nil
  }

  public struct Deployment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String {
      get {return _storage._key}
      set {_uniqueStorage()._key = newValue}
    }

    public var language: String {
      get {return _storage._language}
      set {_uniqueStorage()._language = newValue}
    }

    public var name: String {
      get {return _storage._name}
      set {_uniqueStorage()._name = newValue}
    }

    public var minReplicas: Int32 {
      get {return _storage._minReplicas}
      set {_uniqueStorage()._minReplicas = newValue}
    }

    public var replicas: Int32 {
      get {return _storage._replicas}
      set {_uniqueStorage()._replicas = newValue}
    }

    public var labels: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _storage._labels ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_uniqueStorage()._labels = newValue}
    }
    /// Returns true if `labels` has been explicitly set.
    public var hasLabels: Bool {return _storage._labels != nil}
    /// Clears the value of `labels`. Subsequent reads from it will return its default value.
    public mutating func clearLabels() {_uniqueStorage()._labels = nil}

    public var schema: Xyz_Block_Ftl_V1_Schema_Module {
      get {return _storage._schema ?? Xyz_Block_Ftl_V1_Schema_Module()}
      set {_uniqueStorage()._schema = newValue}
    }
    /// Returns true if `schema` has been explicitly set.
    public var hasSchema: Bool {return _storage._schema != nil}
    /// Clears the value of `schema`. Subsequent reads from it will return its default value.
    public mutating func clearSchema() {_uniqueStorage()._schema = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct IngressRoute {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var deploymentKey: String = String()

    public var verb: Xyz_Block_Ftl_V1_Schema_Ref {
      get {return _verb ?? Xyz_Block_Ftl_V1_Schema_Ref()}
      set {_verb = newValue}
    }
    /// Returns true if `verb` has been explicitly set.
    public var hasVerb: Bool {return self._verb != nil}
    /// Clears the value of `verb`. Subsequent reads from it will return its default value.
    public mutating func clearVerb() {self._verb = nil}

    public var method: String = String()

    public var path: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _verb: Xyz_Block_Ftl_V1_Schema_Ref? = nil
  }

  public struct Route {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var module: String = String()

    public var runner: String = String()

    public var deployment: String = String()

    public var endpoint: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Xyz_Block_Ftl_V1_ProcessListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_ProcessListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var processes: [Xyz_Block_Ftl_V1_ProcessListResponse.Process] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ProcessRunner {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String = String()

    public var endpoint: String = String()

    public var labels: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _labels ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_labels = newValue}
    }
    /// Returns true if `labels` has been explicitly set.
    public var hasLabels: Bool {return self._labels != nil}
    /// Clears the value of `labels`. Subsequent reads from it will return its default value.
    public mutating func clearLabels() {self._labels = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _labels: SwiftProtobuf.Google_Protobuf_Struct? = nil
  }

  public struct Process {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var deployment: String = String()

    public var minReplicas: Int32 = 0

    public var labels: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _labels ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_labels = newValue}
    }
    /// Returns true if `labels` has been explicitly set.
    public var hasLabels: Bool {return self._labels != nil}
    /// Clears the value of `labels`. Subsequent reads from it will return its default value.
    public mutating func clearLabels() {self._labels = nil}

    public var runner: Xyz_Block_Ftl_V1_ProcessListResponse.ProcessRunner {
      get {return _runner ?? Xyz_Block_Ftl_V1_ProcessListResponse.ProcessRunner()}
      set {_runner = newValue}
    }
    /// Returns true if `runner` has been explicitly set.
    public var hasRunner: Bool {return self._runner != nil}
    /// Clears the value of `runner`. Subsequent reads from it will return its default value.
    public mutating func clearRunner() {self._runner = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _labels: SwiftProtobuf.Google_Protobuf_Struct? = nil
    fileprivate var _runner: Xyz_Block_Ftl_V1_ProcessListResponse.ProcessRunner? = nil
  }

  public init() {}
}

public struct Xyz_Block_Ftl_V1_DeployRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deploymentKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_DeployResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_TerminateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deploymentKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_ReserveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deploymentKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_ReserveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_ConfigRef {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var module: String {
    get {return _module ?? String()}
    set {_module = newValue}
  }
  /// Returns true if `module` has been explicitly set.
  public var hasModule: Bool {return self._module != nil}
  /// Clears the value of `module`. Subsequent reads from it will return its default value.
  public mutating func clearModule() {self._module = nil}

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _module: String? = nil
}

public struct Xyz_Block_Ftl_V1_ListConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var module: String {
    get {return _module ?? String()}
    set {_module = newValue}
  }
  /// Returns true if `module` has been explicitly set.
  public var hasModule: Bool {return self._module != nil}
  /// Clears the value of `module`. Subsequent reads from it will return its default value.
  public mutating func clearModule() {self._module = nil}

  public var includeValues: Bool {
    get {return _includeValues ?? false}
    set {_includeValues = newValue}
  }
  /// Returns true if `includeValues` has been explicitly set.
  public var hasIncludeValues: Bool {return self._includeValues != nil}
  /// Clears the value of `includeValues`. Subsequent reads from it will return its default value.
  public mutating func clearIncludeValues() {self._includeValues = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _module: String? = nil
  fileprivate var _includeValues: Bool? = nil
}

public struct Xyz_Block_Ftl_V1_ListConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var configs: [Xyz_Block_Ftl_V1_ListConfigResponse.Config] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Config {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var refPath: String = String()

    public var value: Data {
      get {return _value ?? Data()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _value: Data? = nil
  }

  public init() {}
}

public struct Xyz_Block_Ftl_V1_GetConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ref: Xyz_Block_Ftl_V1_ConfigRef {
    get {return _ref ?? Xyz_Block_Ftl_V1_ConfigRef()}
    set {_ref = newValue}
  }
  /// Returns true if `ref` has been explicitly set.
  public var hasRef: Bool {return self._ref != nil}
  /// Clears the value of `ref`. Subsequent reads from it will return its default value.
  public mutating func clearRef() {self._ref = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ref: Xyz_Block_Ftl_V1_ConfigRef? = nil
}

public struct Xyz_Block_Ftl_V1_GetConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_SetConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var provider: Xyz_Block_Ftl_V1_ConfigProvider {
    get {return _provider ?? .configInline}
    set {_provider = newValue}
  }
  /// Returns true if `provider` has been explicitly set.
  public var hasProvider: Bool {return self._provider != nil}
  /// Clears the value of `provider`. Subsequent reads from it will return its default value.
  public mutating func clearProvider() {self._provider = nil}

  public var ref: Xyz_Block_Ftl_V1_ConfigRef {
    get {return _ref ?? Xyz_Block_Ftl_V1_ConfigRef()}
    set {_ref = newValue}
  }
  /// Returns true if `ref` has been explicitly set.
  public var hasRef: Bool {return self._ref != nil}
  /// Clears the value of `ref`. Subsequent reads from it will return its default value.
  public mutating func clearRef() {self._ref = nil}

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _provider: Xyz_Block_Ftl_V1_ConfigProvider? = nil
  fileprivate var _ref: Xyz_Block_Ftl_V1_ConfigRef? = nil
}

public struct Xyz_Block_Ftl_V1_SetConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_UnsetConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var provider: Xyz_Block_Ftl_V1_ConfigProvider {
    get {return _provider ?? .configInline}
    set {_provider = newValue}
  }
  /// Returns true if `provider` has been explicitly set.
  public var hasProvider: Bool {return self._provider != nil}
  /// Clears the value of `provider`. Subsequent reads from it will return its default value.
  public mutating func clearProvider() {self._provider = nil}

  public var ref: Xyz_Block_Ftl_V1_ConfigRef {
    get {return _ref ?? Xyz_Block_Ftl_V1_ConfigRef()}
    set {_ref = newValue}
  }
  /// Returns true if `ref` has been explicitly set.
  public var hasRef: Bool {return self._ref != nil}
  /// Clears the value of `ref`. Subsequent reads from it will return its default value.
  public mutating func clearRef() {self._ref = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _provider: Xyz_Block_Ftl_V1_ConfigProvider? = nil
  fileprivate var _ref: Xyz_Block_Ftl_V1_ConfigRef? = nil
}

public struct Xyz_Block_Ftl_V1_UnsetConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_ListSecretsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var module: String {
    get {return _module ?? String()}
    set {_module = newValue}
  }
  /// Returns true if `module` has been explicitly set.
  public var hasModule: Bool {return self._module != nil}
  /// Clears the value of `module`. Subsequent reads from it will return its default value.
  public mutating func clearModule() {self._module = nil}

  public var includeValues: Bool {
    get {return _includeValues ?? false}
    set {_includeValues = newValue}
  }
  /// Returns true if `includeValues` has been explicitly set.
  public var hasIncludeValues: Bool {return self._includeValues != nil}
  /// Clears the value of `includeValues`. Subsequent reads from it will return its default value.
  public mutating func clearIncludeValues() {self._includeValues = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _module: String? = nil
  fileprivate var _includeValues: Bool? = nil
}

public struct Xyz_Block_Ftl_V1_ListSecretsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var secrets: [Xyz_Block_Ftl_V1_ListSecretsResponse.Secret] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Secret {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var refPath: String = String()

    public var value: Data {
      get {return _value ?? Data()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _value: Data? = nil
  }

  public init() {}
}

public struct Xyz_Block_Ftl_V1_GetSecretRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ref: Xyz_Block_Ftl_V1_ConfigRef {
    get {return _ref ?? Xyz_Block_Ftl_V1_ConfigRef()}
    set {_ref = newValue}
  }
  /// Returns true if `ref` has been explicitly set.
  public var hasRef: Bool {return self._ref != nil}
  /// Clears the value of `ref`. Subsequent reads from it will return its default value.
  public mutating func clearRef() {self._ref = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ref: Xyz_Block_Ftl_V1_ConfigRef? = nil
}

public struct Xyz_Block_Ftl_V1_GetSecretResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_SetSecretRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var provider: Xyz_Block_Ftl_V1_SecretProvider {
    get {return _provider ?? .secretInline}
    set {_provider = newValue}
  }
  /// Returns true if `provider` has been explicitly set.
  public var hasProvider: Bool {return self._provider != nil}
  /// Clears the value of `provider`. Subsequent reads from it will return its default value.
  public mutating func clearProvider() {self._provider = nil}

  public var ref: Xyz_Block_Ftl_V1_ConfigRef {
    get {return _ref ?? Xyz_Block_Ftl_V1_ConfigRef()}
    set {_ref = newValue}
  }
  /// Returns true if `ref` has been explicitly set.
  public var hasRef: Bool {return self._ref != nil}
  /// Clears the value of `ref`. Subsequent reads from it will return its default value.
  public mutating func clearRef() {self._ref = nil}

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _provider: Xyz_Block_Ftl_V1_SecretProvider? = nil
  fileprivate var _ref: Xyz_Block_Ftl_V1_ConfigRef? = nil
}

public struct Xyz_Block_Ftl_V1_SetSecretResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xyz_Block_Ftl_V1_UnsetSecretRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var provider: Xyz_Block_Ftl_V1_SecretProvider {
    get {return _provider ?? .secretInline}
    set {_provider = newValue}
  }
  /// Returns true if `provider` has been explicitly set.
  public var hasProvider: Bool {return self._provider != nil}
  /// Clears the value of `provider`. Subsequent reads from it will return its default value.
  public mutating func clearProvider() {self._provider = nil}

  public var ref: Xyz_Block_Ftl_V1_ConfigRef {
    get {return _ref ?? Xyz_Block_Ftl_V1_ConfigRef()}
    set {_ref = newValue}
  }
  /// Returns true if `ref` has been explicitly set.
  public var hasRef: Bool {return self._ref != nil}
  /// Clears the value of `ref`. Subsequent reads from it will return its default value.
  public mutating func clearRef() {self._ref = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _provider: Xyz_Block_Ftl_V1_SecretProvider? = nil
  fileprivate var _ref: Xyz_Block_Ftl_V1_ConfigRef? = nil
}

public struct Xyz_Block_Ftl_V1_UnsetSecretResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Xyz_Block_Ftl_V1_DeploymentChangeType: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_RunnerState: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ConfigProvider: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_SecretProvider: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_PingRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_PingResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ModuleContextRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ModuleContextResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ModuleContextResponse.DBType: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ModuleContextResponse.Ref: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ModuleContextResponse.DSN: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Metadata: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Metadata.Pair: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_CallRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_CallResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_CallResponse.OneOf_Response: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_CallResponse.Error: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_AcquireLeaseRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_AcquireLeaseResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_SendFSMEventRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_SendFSMEventResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_PublishEventRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_PublishEventResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_GetSchemaRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_GetSchemaResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_PullSchemaRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_PullSchemaResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_GetArtefactDiffsRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_GetArtefactDiffsResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_UploadArtefactRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_UploadArtefactResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_DeploymentArtefact: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_CreateDeploymentRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_CreateDeploymentResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_GetDeploymentArtefactsRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_GetDeploymentArtefactsResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_GetDeploymentRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_GetDeploymentResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_RegisterRunnerRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_RegisterRunnerResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_UpdateDeployRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_UpdateDeployResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ReplaceDeployRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ReplaceDeployResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_StreamDeploymentLogsRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_StreamDeploymentLogsResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_StatusRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_StatusResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_StatusResponse.Controller: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_StatusResponse.Runner: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_StatusResponse.Deployment: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_StatusResponse.IngressRoute: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_StatusResponse.Route: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ProcessListRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ProcessListResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ProcessListResponse.ProcessRunner: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ProcessListResponse.Process: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_DeployRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_DeployResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_TerminateRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ReserveRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ReserveResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ConfigRef: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ListConfigRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ListConfigResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ListConfigResponse.Config: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_GetConfigRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_GetConfigResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_SetConfigRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_SetConfigResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_UnsetConfigRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_UnsetConfigResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ListSecretsRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ListSecretsResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_ListSecretsResponse.Secret: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_GetSecretRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_GetSecretResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_SetSecretRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_SetSecretResponse: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_UnsetSecretRequest: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_UnsetSecretResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xyz.block.ftl.v1"

extension Xyz_Block_Ftl_V1_DeploymentChangeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEPLOYMENT_ADDED"),
    1: .same(proto: "DEPLOYMENT_REMOVED"),
    2: .same(proto: "DEPLOYMENT_CHANGED"),
  ]
}

extension Xyz_Block_Ftl_V1_RunnerState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RUNNER_IDLE"),
    1: .same(proto: "RUNNER_RESERVED"),
    2: .same(proto: "RUNNER_ASSIGNED"),
    3: .same(proto: "RUNNER_DEAD"),
  ]
}

extension Xyz_Block_Ftl_V1_ConfigProvider: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONFIG_INLINE"),
    1: .same(proto: "CONFIG_ENVAR"),
    2: .same(proto: "CONFIG_DB"),
  ]
}

extension Xyz_Block_Ftl_V1_SecretProvider: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SECRET_INLINE"),
    1: .same(proto: "SECRET_ENVAR"),
    2: .same(proto: "SECRET_KEYCHAIN"),
    3: .same(proto: "SECRET_OP"),
    4: .same(proto: "SECRET_ASM"),
  ]
}

extension Xyz_Block_Ftl_V1_PingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PingRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_PingRequest, rhs: Xyz_Block_Ftl_V1_PingRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_PingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PingResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "not_ready"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._notReady) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._notReady {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_PingResponse, rhs: Xyz_Block_Ftl_V1_PingResponse) -> Bool {
    if lhs._notReady != rhs._notReady {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ModuleContextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModuleContextRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "module"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.module) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.module.isEmpty {
      try visitor.visitSingularStringField(value: self.module, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ModuleContextRequest, rhs: Xyz_Block_Ftl_V1_ModuleContextRequest) -> Bool {
    if lhs.module != rhs.module {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ModuleContextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModuleContextResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "module"),
    2: .same(proto: "configs"),
    3: .same(proto: "secrets"),
    4: .same(proto: "databases"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.module) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.configs) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.secrets) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.databases) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.module.isEmpty {
      try visitor.visitSingularStringField(value: self.module, fieldNumber: 1)
    }
    if !self.configs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.configs, fieldNumber: 2)
    }
    if !self.secrets.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.secrets, fieldNumber: 3)
    }
    if !self.databases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.databases, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ModuleContextResponse, rhs: Xyz_Block_Ftl_V1_ModuleContextResponse) -> Bool {
    if lhs.module != rhs.module {return false}
    if lhs.configs != rhs.configs {return false}
    if lhs.secrets != rhs.secrets {return false}
    if lhs.databases != rhs.databases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ModuleContextResponse.DBType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POSTGRES"),
  ]
}

extension Xyz_Block_Ftl_V1_ModuleContextResponse.Ref: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xyz_Block_Ftl_V1_ModuleContextResponse.protoMessageName + ".Ref"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "module"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._module) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._module {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ModuleContextResponse.Ref, rhs: Xyz_Block_Ftl_V1_ModuleContextResponse.Ref) -> Bool {
    if lhs._module != rhs._module {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ModuleContextResponse.DSN: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xyz_Block_Ftl_V1_ModuleContextResponse.protoMessageName + ".DSN"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "dsn"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dsn) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .postgres {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.dsn.isEmpty {
      try visitor.visitSingularStringField(value: self.dsn, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ModuleContextResponse.DSN, rhs: Xyz_Block_Ftl_V1_ModuleContextResponse.DSN) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.dsn != rhs.dsn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_Metadata, rhs: Xyz_Block_Ftl_V1_Metadata) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Metadata.Pair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xyz_Block_Ftl_V1_Metadata.protoMessageName + ".Pair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_Metadata.Pair, rhs: Xyz_Block_Ftl_V1_Metadata.Pair) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_CallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "verb"),
    3: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._verb) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._verb {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_CallRequest, rhs: Xyz_Block_Ftl_V1_CallRequest) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._verb != rhs._verb {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_CallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .body(v)
        }
      }()
      case 2: try {
        var v: Xyz_Block_Ftl_V1_CallResponse.Error?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .body?: try {
      guard case .body(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_CallResponse, rhs: Xyz_Block_Ftl_V1_CallResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_CallResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xyz_Block_Ftl_V1_CallResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "stack"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._stack) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try { if let v = self._stack {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_CallResponse.Error, rhs: Xyz_Block_Ftl_V1_CallResponse.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._stack != rhs._stack {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_AcquireLeaseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcquireLeaseRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "module"),
    2: .same(proto: "key"),
    3: .same(proto: "ttl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.module) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._ttl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.module.isEmpty {
      try visitor.visitSingularStringField(value: self.module, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitRepeatedStringField(value: self.key, fieldNumber: 2)
    }
    try { if let v = self._ttl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_AcquireLeaseRequest, rhs: Xyz_Block_Ftl_V1_AcquireLeaseRequest) -> Bool {
    if lhs.module != rhs.module {return false}
    if lhs.key != rhs.key {return false}
    if lhs._ttl != rhs._ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_AcquireLeaseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcquireLeaseResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_AcquireLeaseResponse, rhs: Xyz_Block_Ftl_V1_AcquireLeaseResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_SendFSMEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendFSMEventRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fsm"),
    2: .same(proto: "instance"),
    3: .same(proto: "event"),
    4: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fsm) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instance) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fsm {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.instance.isEmpty {
      try visitor.visitSingularStringField(value: self.instance, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_SendFSMEventRequest, rhs: Xyz_Block_Ftl_V1_SendFSMEventRequest) -> Bool {
    if lhs._fsm != rhs._fsm {return false}
    if lhs.instance != rhs.instance {return false}
    if lhs._event != rhs._event {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_SendFSMEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendFSMEventResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_SendFSMEventResponse, rhs: Xyz_Block_Ftl_V1_SendFSMEventResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_PublishEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishEventRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._topic) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_PublishEventRequest, rhs: Xyz_Block_Ftl_V1_PublishEventRequest) -> Bool {
    if lhs._topic != rhs._topic {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_PublishEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishEventResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_PublishEventResponse, rhs: Xyz_Block_Ftl_V1_PublishEventResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_GetSchemaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSchemaRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_GetSchemaRequest, rhs: Xyz_Block_Ftl_V1_GetSchemaRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_GetSchemaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSchemaResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "schema"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._schema) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._schema {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_GetSchemaResponse, rhs: Xyz_Block_Ftl_V1_GetSchemaResponse) -> Bool {
    if lhs._schema != rhs._schema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_PullSchemaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PullSchemaRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_PullSchemaRequest, rhs: Xyz_Block_Ftl_V1_PullSchemaRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_PullSchemaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PullSchemaResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deployment_key"),
    2: .standard(proto: "module_name"),
    4: .same(proto: "schema"),
    3: .same(proto: "more"),
    5: .standard(proto: "change_type"),
  ]

  fileprivate class _StorageClass {
    var _deploymentKey: String = String()
    var _moduleName: String = String()
    var _schema: Xyz_Block_Ftl_V1_Schema_Module? = nil
    var _more: Bool = false
    var _changeType: Xyz_Block_Ftl_V1_DeploymentChangeType = .deploymentAdded

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _deploymentKey = source._deploymentKey
      _moduleName = source._moduleName
      _schema = source._schema
      _more = source._more
      _changeType = source._changeType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._deploymentKey) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._moduleName) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._more) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._schema) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._changeType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._deploymentKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deploymentKey, fieldNumber: 1)
      }
      if !_storage._moduleName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moduleName, fieldNumber: 2)
      }
      if _storage._more != false {
        try visitor.visitSingularBoolField(value: _storage._more, fieldNumber: 3)
      }
      try { if let v = _storage._schema {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._changeType != .deploymentAdded {
        try visitor.visitSingularEnumField(value: _storage._changeType, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_PullSchemaResponse, rhs: Xyz_Block_Ftl_V1_PullSchemaResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._deploymentKey != rhs_storage._deploymentKey {return false}
        if _storage._moduleName != rhs_storage._moduleName {return false}
        if _storage._schema != rhs_storage._schema {return false}
        if _storage._more != rhs_storage._more {return false}
        if _storage._changeType != rhs_storage._changeType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_GetArtefactDiffsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetArtefactDiffsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_digests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.clientDigests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientDigests.isEmpty {
      try visitor.visitRepeatedStringField(value: self.clientDigests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_GetArtefactDiffsRequest, rhs: Xyz_Block_Ftl_V1_GetArtefactDiffsRequest) -> Bool {
    if lhs.clientDigests != rhs.clientDigests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_GetArtefactDiffsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetArtefactDiffsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "missing_digests"),
    2: .standard(proto: "client_artefacts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.missingDigests) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.clientArtefacts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.missingDigests.isEmpty {
      try visitor.visitRepeatedStringField(value: self.missingDigests, fieldNumber: 1)
    }
    if !self.clientArtefacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clientArtefacts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_GetArtefactDiffsResponse, rhs: Xyz_Block_Ftl_V1_GetArtefactDiffsResponse) -> Bool {
    if lhs.missingDigests != rhs.missingDigests {return false}
    if lhs.clientArtefacts != rhs.clientArtefacts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_UploadArtefactRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadArtefactRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_UploadArtefactRequest, rhs: Xyz_Block_Ftl_V1_UploadArtefactRequest) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_UploadArtefactResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadArtefactResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "digest"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self.digest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.digest.isEmpty {
      try visitor.visitSingularBytesField(value: self.digest, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_UploadArtefactResponse, rhs: Xyz_Block_Ftl_V1_UploadArtefactResponse) -> Bool {
    if lhs.digest != rhs.digest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_DeploymentArtefact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeploymentArtefact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "digest"),
    2: .same(proto: "path"),
    3: .same(proto: "executable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.digest) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.executable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.digest.isEmpty {
      try visitor.visitSingularStringField(value: self.digest, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if self.executable != false {
      try visitor.visitSingularBoolField(value: self.executable, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_DeploymentArtefact, rhs: Xyz_Block_Ftl_V1_DeploymentArtefact) -> Bool {
    if lhs.digest != rhs.digest {return false}
    if lhs.path != rhs.path {return false}
    if lhs.executable != rhs.executable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_CreateDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDeploymentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "schema"),
    2: .same(proto: "artefacts"),
    3: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._schema) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.artefacts) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._schema {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.artefacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artefacts, fieldNumber: 2)
    }
    try { if let v = self._labels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_CreateDeploymentRequest, rhs: Xyz_Block_Ftl_V1_CreateDeploymentRequest) -> Bool {
    if lhs._schema != rhs._schema {return false}
    if lhs.artefacts != rhs.artefacts {return false}
    if lhs._labels != rhs._labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_CreateDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDeploymentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deployment_key"),
    2: .standard(proto: "active_deployment_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deploymentKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._activeDeploymentKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deploymentKey.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentKey, fieldNumber: 1)
    }
    try { if let v = self._activeDeploymentKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_CreateDeploymentResponse, rhs: Xyz_Block_Ftl_V1_CreateDeploymentResponse) -> Bool {
    if lhs.deploymentKey != rhs.deploymentKey {return false}
    if lhs._activeDeploymentKey != rhs._activeDeploymentKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_GetDeploymentArtefactsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDeploymentArtefactsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deployment_key"),
    2: .standard(proto: "have_artefacts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deploymentKey) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.haveArtefacts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deploymentKey.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentKey, fieldNumber: 1)
    }
    if !self.haveArtefacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.haveArtefacts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_GetDeploymentArtefactsRequest, rhs: Xyz_Block_Ftl_V1_GetDeploymentArtefactsRequest) -> Bool {
    if lhs.deploymentKey != rhs.deploymentKey {return false}
    if lhs.haveArtefacts != rhs.haveArtefacts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_GetDeploymentArtefactsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDeploymentArtefactsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "artefact"),
    2: .same(proto: "chunk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._artefact) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.chunk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._artefact {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.chunk.isEmpty {
      try visitor.visitSingularBytesField(value: self.chunk, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_GetDeploymentArtefactsResponse, rhs: Xyz_Block_Ftl_V1_GetDeploymentArtefactsResponse) -> Bool {
    if lhs._artefact != rhs._artefact {return false}
    if lhs.chunk != rhs.chunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_GetDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDeploymentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deployment_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deploymentKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deploymentKey.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_GetDeploymentRequest, rhs: Xyz_Block_Ftl_V1_GetDeploymentRequest) -> Bool {
    if lhs.deploymentKey != rhs.deploymentKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_GetDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDeploymentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "schema"),
    2: .same(proto: "artefacts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._schema) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.artefacts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._schema {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.artefacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artefacts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_GetDeploymentResponse, rhs: Xyz_Block_Ftl_V1_GetDeploymentResponse) -> Bool {
    if lhs._schema != rhs._schema {return false}
    if lhs.artefacts != rhs.artefacts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_RegisterRunnerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterRunnerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "endpoint"),
    3: .same(proto: "deployment"),
    4: .same(proto: "state"),
    5: .same(proto: "labels"),
    7: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._deployment) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._labels) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 2)
    }
    try { if let v = self._deployment {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if self.state != .runnerIdle {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    try { if let v = self._labels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_RegisterRunnerRequest, rhs: Xyz_Block_Ftl_V1_RegisterRunnerRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs.state != rhs.state {return false}
    if lhs._labels != rhs._labels {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_RegisterRunnerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterRunnerResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_RegisterRunnerResponse, rhs: Xyz_Block_Ftl_V1_RegisterRunnerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_UpdateDeployRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDeployRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deployment_key"),
    2: .standard(proto: "min_replicas"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deploymentKey) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.minReplicas) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deploymentKey.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentKey, fieldNumber: 1)
    }
    if self.minReplicas != 0 {
      try visitor.visitSingularInt32Field(value: self.minReplicas, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_UpdateDeployRequest, rhs: Xyz_Block_Ftl_V1_UpdateDeployRequest) -> Bool {
    if lhs.deploymentKey != rhs.deploymentKey {return false}
    if lhs.minReplicas != rhs.minReplicas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_UpdateDeployResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDeployResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_UpdateDeployResponse, rhs: Xyz_Block_Ftl_V1_UpdateDeployResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ReplaceDeployRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplaceDeployRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deployment_key"),
    2: .standard(proto: "min_replicas"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deploymentKey) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.minReplicas) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deploymentKey.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentKey, fieldNumber: 1)
    }
    if self.minReplicas != 0 {
      try visitor.visitSingularInt32Field(value: self.minReplicas, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ReplaceDeployRequest, rhs: Xyz_Block_Ftl_V1_ReplaceDeployRequest) -> Bool {
    if lhs.deploymentKey != rhs.deploymentKey {return false}
    if lhs.minReplicas != rhs.minReplicas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ReplaceDeployResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplaceDeployResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ReplaceDeployResponse, rhs: Xyz_Block_Ftl_V1_ReplaceDeployResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_StreamDeploymentLogsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamDeploymentLogsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deployment_key"),
    2: .standard(proto: "request_key"),
    3: .standard(proto: "time_stamp"),
    4: .standard(proto: "log_level"),
    5: .same(proto: "attributes"),
    6: .same(proto: "message"),
    7: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deploymentKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._requestKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeStamp) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.logLevel) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attributes) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deploymentKey.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentKey, fieldNumber: 1)
    }
    try { if let v = self._requestKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timeStamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.logLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.logLevel, fieldNumber: 4)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attributes, fieldNumber: 5)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 6)
    }
    try { if let v = self._error {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_StreamDeploymentLogsRequest, rhs: Xyz_Block_Ftl_V1_StreamDeploymentLogsRequest) -> Bool {
    if lhs.deploymentKey != rhs.deploymentKey {return false}
    if lhs._requestKey != rhs._requestKey {return false}
    if lhs._timeStamp != rhs._timeStamp {return false}
    if lhs.logLevel != rhs.logLevel {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.message != rhs.message {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_StreamDeploymentLogsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamDeploymentLogsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_StreamDeploymentLogsResponse, rhs: Xyz_Block_Ftl_V1_StreamDeploymentLogsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_StatusRequest, rhs: Xyz_Block_Ftl_V1_StatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "controllers"),
    2: .same(proto: "runners"),
    3: .same(proto: "deployments"),
    4: .standard(proto: "ingress_routes"),
    5: .same(proto: "routes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.controllers) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.runners) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.deployments) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.ingressRoutes) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.routes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.controllers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.controllers, fieldNumber: 1)
    }
    if !self.runners.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.runners, fieldNumber: 2)
    }
    if !self.deployments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deployments, fieldNumber: 3)
    }
    if !self.ingressRoutes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ingressRoutes, fieldNumber: 4)
    }
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_StatusResponse, rhs: Xyz_Block_Ftl_V1_StatusResponse) -> Bool {
    if lhs.controllers != rhs.controllers {return false}
    if lhs.runners != rhs.runners {return false}
    if lhs.deployments != rhs.deployments {return false}
    if lhs.ingressRoutes != rhs.ingressRoutes {return false}
    if lhs.routes != rhs.routes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_StatusResponse.Controller: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xyz_Block_Ftl_V1_StatusResponse.protoMessageName + ".Controller"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "endpoint"),
    3: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_StatusResponse.Controller, rhs: Xyz_Block_Ftl_V1_StatusResponse.Controller) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_StatusResponse.Runner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xyz_Block_Ftl_V1_StatusResponse.protoMessageName + ".Runner"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "languages"),
    3: .same(proto: "endpoint"),
    4: .same(proto: "state"),
    5: .same(proto: "deployment"),
    6: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.languages) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._deployment) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.languages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.languages, fieldNumber: 2)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 3)
    }
    if self.state != .runnerIdle {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    try { if let v = self._deployment {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._labels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_StatusResponse.Runner, rhs: Xyz_Block_Ftl_V1_StatusResponse.Runner) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.languages != rhs.languages {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.state != rhs.state {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs._labels != rhs._labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_StatusResponse.Deployment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xyz_Block_Ftl_V1_StatusResponse.protoMessageName + ".Deployment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "language"),
    3: .same(proto: "name"),
    4: .standard(proto: "min_replicas"),
    7: .same(proto: "replicas"),
    5: .same(proto: "labels"),
    6: .same(proto: "schema"),
  ]

  fileprivate class _StorageClass {
    var _key: String = String()
    var _language: String = String()
    var _name: String = String()
    var _minReplicas: Int32 = 0
    var _replicas: Int32 = 0
    var _labels: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _schema: Xyz_Block_Ftl_V1_Schema_Module? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _language = source._language
      _name = source._name
      _minReplicas = source._minReplicas
      _replicas = source._replicas
      _labels = source._labels
      _schema = source._schema
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._key) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._language) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._minReplicas) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._labels) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._schema) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._replicas) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 1)
      }
      if !_storage._language.isEmpty {
        try visitor.visitSingularStringField(value: _storage._language, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if _storage._minReplicas != 0 {
        try visitor.visitSingularInt32Field(value: _storage._minReplicas, fieldNumber: 4)
      }
      try { if let v = _storage._labels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._schema {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._replicas != 0 {
        try visitor.visitSingularInt32Field(value: _storage._replicas, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_StatusResponse.Deployment, rhs: Xyz_Block_Ftl_V1_StatusResponse.Deployment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._language != rhs_storage._language {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._minReplicas != rhs_storage._minReplicas {return false}
        if _storage._replicas != rhs_storage._replicas {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._schema != rhs_storage._schema {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_StatusResponse.IngressRoute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xyz_Block_Ftl_V1_StatusResponse.protoMessageName + ".IngressRoute"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deployment_key"),
    2: .same(proto: "verb"),
    3: .same(proto: "method"),
    4: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deploymentKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._verb) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.method) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deploymentKey.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentKey, fieldNumber: 1)
    }
    try { if let v = self._verb {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 3)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_StatusResponse.IngressRoute, rhs: Xyz_Block_Ftl_V1_StatusResponse.IngressRoute) -> Bool {
    if lhs.deploymentKey != rhs.deploymentKey {return false}
    if lhs._verb != rhs._verb {return false}
    if lhs.method != rhs.method {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_StatusResponse.Route: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xyz_Block_Ftl_V1_StatusResponse.protoMessageName + ".Route"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "module"),
    2: .same(proto: "runner"),
    3: .same(proto: "deployment"),
    4: .same(proto: "endpoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.module) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runner) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deployment) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.module.isEmpty {
      try visitor.visitSingularStringField(value: self.module, fieldNumber: 1)
    }
    if !self.runner.isEmpty {
      try visitor.visitSingularStringField(value: self.runner, fieldNumber: 2)
    }
    if !self.deployment.isEmpty {
      try visitor.visitSingularStringField(value: self.deployment, fieldNumber: 3)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_StatusResponse.Route, rhs: Xyz_Block_Ftl_V1_StatusResponse.Route) -> Bool {
    if lhs.module != rhs.module {return false}
    if lhs.runner != rhs.runner {return false}
    if lhs.deployment != rhs.deployment {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ProcessListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProcessListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ProcessListRequest, rhs: Xyz_Block_Ftl_V1_ProcessListRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ProcessListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProcessListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "processes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.processes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.processes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.processes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ProcessListResponse, rhs: Xyz_Block_Ftl_V1_ProcessListResponse) -> Bool {
    if lhs.processes != rhs.processes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ProcessListResponse.ProcessRunner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xyz_Block_Ftl_V1_ProcessListResponse.protoMessageName + ".ProcessRunner"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "endpoint"),
    3: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 2)
    }
    try { if let v = self._labels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ProcessListResponse.ProcessRunner, rhs: Xyz_Block_Ftl_V1_ProcessListResponse.ProcessRunner) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs._labels != rhs._labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ProcessListResponse.Process: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xyz_Block_Ftl_V1_ProcessListResponse.protoMessageName + ".Process"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deployment"),
    2: .standard(proto: "min_replicas"),
    3: .same(proto: "labels"),
    4: .same(proto: "runner"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deployment) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.minReplicas) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._labels) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._runner) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deployment.isEmpty {
      try visitor.visitSingularStringField(value: self.deployment, fieldNumber: 1)
    }
    if self.minReplicas != 0 {
      try visitor.visitSingularInt32Field(value: self.minReplicas, fieldNumber: 2)
    }
    try { if let v = self._labels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._runner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ProcessListResponse.Process, rhs: Xyz_Block_Ftl_V1_ProcessListResponse.Process) -> Bool {
    if lhs.deployment != rhs.deployment {return false}
    if lhs.minReplicas != rhs.minReplicas {return false}
    if lhs._labels != rhs._labels {return false}
    if lhs._runner != rhs._runner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_DeployRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeployRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deployment_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deploymentKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deploymentKey.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_DeployRequest, rhs: Xyz_Block_Ftl_V1_DeployRequest) -> Bool {
    if lhs.deploymentKey != rhs.deploymentKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_DeployResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeployResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_DeployResponse, rhs: Xyz_Block_Ftl_V1_DeployResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_TerminateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deployment_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deploymentKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deploymentKey.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_TerminateRequest, rhs: Xyz_Block_Ftl_V1_TerminateRequest) -> Bool {
    if lhs.deploymentKey != rhs.deploymentKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ReserveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReserveRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deployment_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deploymentKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deploymentKey.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ReserveRequest, rhs: Xyz_Block_Ftl_V1_ReserveRequest) -> Bool {
    if lhs.deploymentKey != rhs.deploymentKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ReserveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReserveResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ReserveResponse, rhs: Xyz_Block_Ftl_V1_ReserveResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ConfigRef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigRef"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "module"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._module) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._module {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ConfigRef, rhs: Xyz_Block_Ftl_V1_ConfigRef) -> Bool {
    if lhs._module != rhs._module {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ListConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "module"),
    2: .standard(proto: "include_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._module) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._includeValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._module {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._includeValues {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ListConfigRequest, rhs: Xyz_Block_Ftl_V1_ListConfigRequest) -> Bool {
    if lhs._module != rhs._module {return false}
    if lhs._includeValues != rhs._includeValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ListConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConfigResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "configs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.configs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.configs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.configs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ListConfigResponse, rhs: Xyz_Block_Ftl_V1_ListConfigResponse) -> Bool {
    if lhs.configs != rhs.configs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ListConfigResponse.Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xyz_Block_Ftl_V1_ListConfigResponse.protoMessageName + ".Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "refPath"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.refPath) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.refPath.isEmpty {
      try visitor.visitSingularStringField(value: self.refPath, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ListConfigResponse.Config, rhs: Xyz_Block_Ftl_V1_ListConfigResponse.Config) -> Bool {
    if lhs.refPath != rhs.refPath {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_GetConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ref"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ref) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ref {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_GetConfigRequest, rhs: Xyz_Block_Ftl_V1_GetConfigRequest) -> Bool {
    if lhs._ref != rhs._ref {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_GetConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConfigResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_GetConfigResponse, rhs: Xyz_Block_Ftl_V1_GetConfigResponse) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_SetConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
    2: .same(proto: "ref"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._provider) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ref) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._provider {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ref {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_SetConfigRequest, rhs: Xyz_Block_Ftl_V1_SetConfigRequest) -> Bool {
    if lhs._provider != rhs._provider {return false}
    if lhs._ref != rhs._ref {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_SetConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetConfigResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_SetConfigResponse, rhs: Xyz_Block_Ftl_V1_SetConfigResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_UnsetConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnsetConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
    2: .same(proto: "ref"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._provider) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ref) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._provider {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ref {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_UnsetConfigRequest, rhs: Xyz_Block_Ftl_V1_UnsetConfigRequest) -> Bool {
    if lhs._provider != rhs._provider {return false}
    if lhs._ref != rhs._ref {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_UnsetConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnsetConfigResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_UnsetConfigResponse, rhs: Xyz_Block_Ftl_V1_UnsetConfigResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ListSecretsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSecretsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "module"),
    2: .standard(proto: "include_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._module) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._includeValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._module {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._includeValues {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ListSecretsRequest, rhs: Xyz_Block_Ftl_V1_ListSecretsRequest) -> Bool {
    if lhs._module != rhs._module {return false}
    if lhs._includeValues != rhs._includeValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ListSecretsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSecretsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "secrets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.secrets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.secrets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.secrets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ListSecretsResponse, rhs: Xyz_Block_Ftl_V1_ListSecretsResponse) -> Bool {
    if lhs.secrets != rhs.secrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_ListSecretsResponse.Secret: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xyz_Block_Ftl_V1_ListSecretsResponse.protoMessageName + ".Secret"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "refPath"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.refPath) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.refPath.isEmpty {
      try visitor.visitSingularStringField(value: self.refPath, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_ListSecretsResponse.Secret, rhs: Xyz_Block_Ftl_V1_ListSecretsResponse.Secret) -> Bool {
    if lhs.refPath != rhs.refPath {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_GetSecretRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSecretRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ref"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ref) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ref {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_GetSecretRequest, rhs: Xyz_Block_Ftl_V1_GetSecretRequest) -> Bool {
    if lhs._ref != rhs._ref {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_GetSecretResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSecretResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_GetSecretResponse, rhs: Xyz_Block_Ftl_V1_GetSecretResponse) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_SetSecretRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSecretRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
    2: .same(proto: "ref"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._provider) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ref) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._provider {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ref {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_SetSecretRequest, rhs: Xyz_Block_Ftl_V1_SetSecretRequest) -> Bool {
    if lhs._provider != rhs._provider {return false}
    if lhs._ref != rhs._ref {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_SetSecretResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSecretResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_SetSecretResponse, rhs: Xyz_Block_Ftl_V1_SetSecretResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_UnsetSecretRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnsetSecretRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
    2: .same(proto: "ref"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._provider) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ref) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._provider {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ref {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_UnsetSecretRequest, rhs: Xyz_Block_Ftl_V1_UnsetSecretRequest) -> Bool {
    if lhs._provider != rhs._provider {return false}
    if lhs._ref != rhs._ref {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_UnsetSecretResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnsetSecretResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xyz_Block_Ftl_V1_UnsetSecretResponse, rhs: Xyz_Block_Ftl_V1_UnsetSecretResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
