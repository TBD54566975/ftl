// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: backend/protos/xyz/block/ftl/v1/schema/schema.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Xyz_Block_Ftl_V1_Schema_Any {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Array {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _storage._pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_uniqueStorage()._pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return _storage._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {_uniqueStorage()._pos = nil}

  var element: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _storage._element ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_uniqueStorage()._element = newValue}
  }
  /// Returns true if `element` has been explicitly set.
  var hasElement: Bool {return _storage._element != nil}
  /// Clears the value of `element`. Subsequent reads from it will return its default value.
  mutating func clearElement() {_uniqueStorage()._element = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Xyz_Block_Ftl_V1_Schema_Bool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Bytes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Config {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var comments: [String] = []

  var name: String = String()

  var type: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _type ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
  fileprivate var _type: Xyz_Block_Ftl_V1_Schema_Type? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var comments: [String] = []

  var export: Bool = false

  var name: String = String()

  var typeParameters: [Xyz_Block_Ftl_V1_Schema_TypeParameter] = []

  var fields: [Xyz_Block_Ftl_V1_Schema_Field] = []

  var metadata: [Xyz_Block_Ftl_V1_Schema_Metadata] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Database {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var comments: [String] = []

  var name: String = String()

  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Decl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Xyz_Block_Ftl_V1_Schema_Decl.OneOf_Value? = nil

  var data: Xyz_Block_Ftl_V1_Schema_Data {
    get {
      if case .data(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_Data()
    }
    set {value = .data(newValue)}
  }

  var verb: Xyz_Block_Ftl_V1_Schema_Verb {
    get {
      if case .verb(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_Verb()
    }
    set {value = .verb(newValue)}
  }

  var database: Xyz_Block_Ftl_V1_Schema_Database {
    get {
      if case .database(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_Database()
    }
    set {value = .database(newValue)}
  }

  var `enum`: Xyz_Block_Ftl_V1_Schema_Enum {
    get {
      if case .enum(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_Enum()
    }
    set {value = .enum(newValue)}
  }

  var typeAlias: Xyz_Block_Ftl_V1_Schema_TypeAlias {
    get {
      if case .typeAlias(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_TypeAlias()
    }
    set {value = .typeAlias(newValue)}
  }

  var config: Xyz_Block_Ftl_V1_Schema_Config {
    get {
      if case .config(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_Config()
    }
    set {value = .config(newValue)}
  }

  var secret: Xyz_Block_Ftl_V1_Schema_Secret {
    get {
      if case .secret(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_Secret()
    }
    set {value = .secret(newValue)}
  }

  var fsm: Xyz_Block_Ftl_V1_Schema_FSM {
    get {
      if case .fsm(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_FSM()
    }
    set {value = .fsm(newValue)}
  }

  var topic: Xyz_Block_Ftl_V1_Schema_Topic {
    get {
      if case .topic(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_Topic()
    }
    set {value = .topic(newValue)}
  }

  var subscription: Xyz_Block_Ftl_V1_Schema_Subscription {
    get {
      if case .subscription(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_Subscription()
    }
    set {value = .subscription(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case data(Xyz_Block_Ftl_V1_Schema_Data)
    case verb(Xyz_Block_Ftl_V1_Schema_Verb)
    case database(Xyz_Block_Ftl_V1_Schema_Database)
    case `enum`(Xyz_Block_Ftl_V1_Schema_Enum)
    case typeAlias(Xyz_Block_Ftl_V1_Schema_TypeAlias)
    case config(Xyz_Block_Ftl_V1_Schema_Config)
    case secret(Xyz_Block_Ftl_V1_Schema_Secret)
    case fsm(Xyz_Block_Ftl_V1_Schema_FSM)
    case topic(Xyz_Block_Ftl_V1_Schema_Topic)
    case subscription(Xyz_Block_Ftl_V1_Schema_Subscription)

  #if !swift(>=4.1)
    static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Decl.OneOf_Value, rhs: Xyz_Block_Ftl_V1_Schema_Decl.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verb, .verb): return {
        guard case .verb(let l) = lhs, case .verb(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.database, .database): return {
        guard case .database(let l) = lhs, case .database(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.enum, .enum): return {
        guard case .enum(let l) = lhs, case .enum(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.typeAlias, .typeAlias): return {
        guard case .typeAlias(let l) = lhs, case .typeAlias(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.config, .config): return {
        guard case .config(let l) = lhs, case .config(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.secret, .secret): return {
        guard case .secret(let l) = lhs, case .secret(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fsm, .fsm): return {
        guard case .fsm(let l) = lhs, case .fsm(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.topic, .topic): return {
        guard case .topic(let l) = lhs, case .topic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscription, .subscription): return {
        guard case .subscription(let l) = lhs, case .subscription(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Xyz_Block_Ftl_V1_Schema_Enum {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var comments: [String] = []

  var export: Bool = false

  var name: String = String()

  var type: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _type ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var variants: [Xyz_Block_Ftl_V1_Schema_EnumVariant] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
  fileprivate var _type: Xyz_Block_Ftl_V1_Schema_Type? = nil
}

struct Xyz_Block_Ftl_V1_Schema_EnumVariant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var comments: [String] = []

  var name: String = String()

  var value: Xyz_Block_Ftl_V1_Schema_Value {
    get {return _value ?? Xyz_Block_Ftl_V1_Schema_Value()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
  fileprivate var _value: Xyz_Block_Ftl_V1_Schema_Value? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: String = String()

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var endColumn: Int64 = 0

  var level: Xyz_Block_Ftl_V1_Schema_Error.ErrorLevel = .info

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ErrorLevel: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case info // = 0
    case warn // = 1
    case error // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .info
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .info
      case 1: self = .warn
      case 2: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .info: return 0
      case .warn: return 1
      case .error: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

#if swift(>=4.2)

extension Xyz_Block_Ftl_V1_Schema_Error.ErrorLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Xyz_Block_Ftl_V1_Schema_Error.ErrorLevel] = [
    .info,
    .warn,
    .error,
  ]
}

#endif  // swift(>=4.2)

struct Xyz_Block_Ftl_V1_Schema_ErrorList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errors: [Xyz_Block_Ftl_V1_Schema_Error] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Xyz_Block_Ftl_V1_Schema_FSM {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var comments: [String] = []

  var name: String = String()

  var start: [Xyz_Block_Ftl_V1_Schema_Ref] = []

  var transitions: [Xyz_Block_Ftl_V1_Schema_FSMTransition] = []

  var metadata: [Xyz_Block_Ftl_V1_Schema_Metadata] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_FSMTransition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var comments: [String] = []

  var from: Xyz_Block_Ftl_V1_Schema_Ref {
    get {return _from ?? Xyz_Block_Ftl_V1_Schema_Ref()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  var to: Xyz_Block_Ftl_V1_Schema_Ref {
    get {return _to ?? Xyz_Block_Ftl_V1_Schema_Ref()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  mutating func clearTo() {self._to = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
  fileprivate var _from: Xyz_Block_Ftl_V1_Schema_Ref? = nil
  fileprivate var _to: Xyz_Block_Ftl_V1_Schema_Ref? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Field {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var name: String = String()

  var comments: [String] = []

  var type: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _type ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var metadata: [Xyz_Block_Ftl_V1_Schema_Metadata] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
  fileprivate var _type: Xyz_Block_Ftl_V1_Schema_Type? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Float {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_IngressPathComponent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Xyz_Block_Ftl_V1_Schema_IngressPathComponent.OneOf_Value? = nil

  var ingressPathLiteral: Xyz_Block_Ftl_V1_Schema_IngressPathLiteral {
    get {
      if case .ingressPathLiteral(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_IngressPathLiteral()
    }
    set {value = .ingressPathLiteral(newValue)}
  }

  var ingressPathParameter: Xyz_Block_Ftl_V1_Schema_IngressPathParameter {
    get {
      if case .ingressPathParameter(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_IngressPathParameter()
    }
    set {value = .ingressPathParameter(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case ingressPathLiteral(Xyz_Block_Ftl_V1_Schema_IngressPathLiteral)
    case ingressPathParameter(Xyz_Block_Ftl_V1_Schema_IngressPathParameter)

  #if !swift(>=4.1)
    static func ==(lhs: Xyz_Block_Ftl_V1_Schema_IngressPathComponent.OneOf_Value, rhs: Xyz_Block_Ftl_V1_Schema_IngressPathComponent.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ingressPathLiteral, .ingressPathLiteral): return {
        guard case .ingressPathLiteral(let l) = lhs, case .ingressPathLiteral(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ingressPathParameter, .ingressPathParameter): return {
        guard case .ingressPathParameter(let l) = lhs, case .ingressPathParameter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Xyz_Block_Ftl_V1_Schema_IngressPathLiteral {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var text: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_IngressPathParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Int {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_IntValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var value: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Map {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _storage._pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_uniqueStorage()._pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return _storage._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {_uniqueStorage()._pos = nil}

  var key: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _storage._key ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {_uniqueStorage()._key = nil}

  var value: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _storage._value ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {_uniqueStorage()._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Xyz_Block_Ftl_V1_Schema_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Xyz_Block_Ftl_V1_Schema_Metadata.OneOf_Value? = nil

  var calls: Xyz_Block_Ftl_V1_Schema_MetadataCalls {
    get {
      if case .calls(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_MetadataCalls()
    }
    set {value = .calls(newValue)}
  }

  var ingress: Xyz_Block_Ftl_V1_Schema_MetadataIngress {
    get {
      if case .ingress(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_MetadataIngress()
    }
    set {value = .ingress(newValue)}
  }

  var cronJob: Xyz_Block_Ftl_V1_Schema_MetadataCronJob {
    get {
      if case .cronJob(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_MetadataCronJob()
    }
    set {value = .cronJob(newValue)}
  }

  var databases: Xyz_Block_Ftl_V1_Schema_MetadataDatabases {
    get {
      if case .databases(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_MetadataDatabases()
    }
    set {value = .databases(newValue)}
  }

  var alias: Xyz_Block_Ftl_V1_Schema_MetadataAlias {
    get {
      if case .alias(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_MetadataAlias()
    }
    set {value = .alias(newValue)}
  }

  var retry: Xyz_Block_Ftl_V1_Schema_MetadataRetry {
    get {
      if case .retry(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_MetadataRetry()
    }
    set {value = .retry(newValue)}
  }

  var subscriber: Xyz_Block_Ftl_V1_Schema_MetadataSubscriber {
    get {
      if case .subscriber(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_MetadataSubscriber()
    }
    set {value = .subscriber(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case calls(Xyz_Block_Ftl_V1_Schema_MetadataCalls)
    case ingress(Xyz_Block_Ftl_V1_Schema_MetadataIngress)
    case cronJob(Xyz_Block_Ftl_V1_Schema_MetadataCronJob)
    case databases(Xyz_Block_Ftl_V1_Schema_MetadataDatabases)
    case alias(Xyz_Block_Ftl_V1_Schema_MetadataAlias)
    case retry(Xyz_Block_Ftl_V1_Schema_MetadataRetry)
    case subscriber(Xyz_Block_Ftl_V1_Schema_MetadataSubscriber)

  #if !swift(>=4.1)
    static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Metadata.OneOf_Value, rhs: Xyz_Block_Ftl_V1_Schema_Metadata.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.calls, .calls): return {
        guard case .calls(let l) = lhs, case .calls(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ingress, .ingress): return {
        guard case .ingress(let l) = lhs, case .ingress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cronJob, .cronJob): return {
        guard case .cronJob(let l) = lhs, case .cronJob(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.databases, .databases): return {
        guard case .databases(let l) = lhs, case .databases(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.alias, .alias): return {
        guard case .alias(let l) = lhs, case .alias(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.retry, .retry): return {
        guard case .retry(let l) = lhs, case .retry(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscriber, .subscriber): return {
        guard case .subscriber(let l) = lhs, case .subscriber(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Xyz_Block_Ftl_V1_Schema_MetadataAlias {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var kind: Int64 = 0

  var alias: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_MetadataCalls {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var calls: [Xyz_Block_Ftl_V1_Schema_Ref] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_MetadataCronJob {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var cron: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_MetadataDatabases {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var calls: [Xyz_Block_Ftl_V1_Schema_Ref] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_MetadataIngress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var type: String = String()

  var method: String = String()

  var path: [Xyz_Block_Ftl_V1_Schema_IngressPathComponent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_MetadataRetry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var count: Int64 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {self._count = nil}

  var minBackoff: String = String()

  var maxBackoff: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
  fileprivate var _count: Int64? = nil
}

struct Xyz_Block_Ftl_V1_Schema_MetadataSubscriber {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Module {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var runtime: Xyz_Block_Ftl_V1_Schema_ModuleRuntime {
    get {return _runtime ?? Xyz_Block_Ftl_V1_Schema_ModuleRuntime()}
    set {_runtime = newValue}
  }
  /// Returns true if `runtime` has been explicitly set.
  var hasRuntime: Bool {return self._runtime != nil}
  /// Clears the value of `runtime`. Subsequent reads from it will return its default value.
  mutating func clearRuntime() {self._runtime = nil}

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var comments: [String] = []

  var builtin: Bool = false

  var name: String = String()

  var decls: [Xyz_Block_Ftl_V1_Schema_Decl] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _runtime: Xyz_Block_Ftl_V1_Schema_ModuleRuntime? = nil
  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Optional {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _storage._pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_uniqueStorage()._pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return _storage._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {_uniqueStorage()._pos = nil}

  var type: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _storage._type ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Xyz_Block_Ftl_V1_Schema_Position {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var filename: String = String()

  var line: Int64 = 0

  var column: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Xyz_Block_Ftl_V1_Schema_Ref {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var name: String = String()

  var module: String = String()

  var typeParameters: [Xyz_Block_Ftl_V1_Schema_Type] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Schema {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var modules: [Xyz_Block_Ftl_V1_Schema_Module] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Secret {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var comments: [String] = []

  var name: String = String()

  var type: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _type ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
  fileprivate var _type: Xyz_Block_Ftl_V1_Schema_Type? = nil
}

struct Xyz_Block_Ftl_V1_Schema_String {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_StringValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Subscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var comments: [String] = []

  var name: String = String()

  var topic: Xyz_Block_Ftl_V1_Schema_Ref {
    get {return _topic ?? Xyz_Block_Ftl_V1_Schema_Ref()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  mutating func clearTopic() {self._topic = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
  fileprivate var _topic: Xyz_Block_Ftl_V1_Schema_Ref? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Time {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Topic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var comments: [String] = []

  var export: Bool = false

  var name: String = String()

  var event: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _event ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  mutating func clearEvent() {self._event = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
  fileprivate var _event: Xyz_Block_Ftl_V1_Schema_Type? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Type {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  var int: Xyz_Block_Ftl_V1_Schema_Int {
    get {
      if case .int(let v)? = _storage._value {return v}
      return Xyz_Block_Ftl_V1_Schema_Int()
    }
    set {_uniqueStorage()._value = .int(newValue)}
  }

  var float: Xyz_Block_Ftl_V1_Schema_Float {
    get {
      if case .float(let v)? = _storage._value {return v}
      return Xyz_Block_Ftl_V1_Schema_Float()
    }
    set {_uniqueStorage()._value = .float(newValue)}
  }

  var string: Xyz_Block_Ftl_V1_Schema_String {
    get {
      if case .string(let v)? = _storage._value {return v}
      return Xyz_Block_Ftl_V1_Schema_String()
    }
    set {_uniqueStorage()._value = .string(newValue)}
  }

  var bytes: Xyz_Block_Ftl_V1_Schema_Bytes {
    get {
      if case .bytes(let v)? = _storage._value {return v}
      return Xyz_Block_Ftl_V1_Schema_Bytes()
    }
    set {_uniqueStorage()._value = .bytes(newValue)}
  }

  var bool: Xyz_Block_Ftl_V1_Schema_Bool {
    get {
      if case .bool(let v)? = _storage._value {return v}
      return Xyz_Block_Ftl_V1_Schema_Bool()
    }
    set {_uniqueStorage()._value = .bool(newValue)}
  }

  var time: Xyz_Block_Ftl_V1_Schema_Time {
    get {
      if case .time(let v)? = _storage._value {return v}
      return Xyz_Block_Ftl_V1_Schema_Time()
    }
    set {_uniqueStorage()._value = .time(newValue)}
  }

  var array: Xyz_Block_Ftl_V1_Schema_Array {
    get {
      if case .array(let v)? = _storage._value {return v}
      return Xyz_Block_Ftl_V1_Schema_Array()
    }
    set {_uniqueStorage()._value = .array(newValue)}
  }

  var map: Xyz_Block_Ftl_V1_Schema_Map {
    get {
      if case .map(let v)? = _storage._value {return v}
      return Xyz_Block_Ftl_V1_Schema_Map()
    }
    set {_uniqueStorage()._value = .map(newValue)}
  }

  var any: Xyz_Block_Ftl_V1_Schema_Any {
    get {
      if case .any(let v)? = _storage._value {return v}
      return Xyz_Block_Ftl_V1_Schema_Any()
    }
    set {_uniqueStorage()._value = .any(newValue)}
  }

  var unit: Xyz_Block_Ftl_V1_Schema_Unit {
    get {
      if case .unit(let v)? = _storage._value {return v}
      return Xyz_Block_Ftl_V1_Schema_Unit()
    }
    set {_uniqueStorage()._value = .unit(newValue)}
  }

  var ref: Xyz_Block_Ftl_V1_Schema_Ref {
    get {
      if case .ref(let v)? = _storage._value {return v}
      return Xyz_Block_Ftl_V1_Schema_Ref()
    }
    set {_uniqueStorage()._value = .ref(newValue)}
  }

  var optional: Xyz_Block_Ftl_V1_Schema_Optional {
    get {
      if case .optional(let v)? = _storage._value {return v}
      return Xyz_Block_Ftl_V1_Schema_Optional()
    }
    set {_uniqueStorage()._value = .optional(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case int(Xyz_Block_Ftl_V1_Schema_Int)
    case float(Xyz_Block_Ftl_V1_Schema_Float)
    case string(Xyz_Block_Ftl_V1_Schema_String)
    case bytes(Xyz_Block_Ftl_V1_Schema_Bytes)
    case bool(Xyz_Block_Ftl_V1_Schema_Bool)
    case time(Xyz_Block_Ftl_V1_Schema_Time)
    case array(Xyz_Block_Ftl_V1_Schema_Array)
    case map(Xyz_Block_Ftl_V1_Schema_Map)
    case any(Xyz_Block_Ftl_V1_Schema_Any)
    case unit(Xyz_Block_Ftl_V1_Schema_Unit)
    case ref(Xyz_Block_Ftl_V1_Schema_Ref)
    case optional(Xyz_Block_Ftl_V1_Schema_Optional)

  #if !swift(>=4.1)
    static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Type.OneOf_Value, rhs: Xyz_Block_Ftl_V1_Schema_Type.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.int, .int): return {
        guard case .int(let l) = lhs, case .int(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.float, .float): return {
        guard case .float(let l) = lhs, case .float(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.string, .string): return {
        guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bytes, .bytes): return {
        guard case .bytes(let l) = lhs, case .bytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bool, .bool): return {
        guard case .bool(let l) = lhs, case .bool(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.time, .time): return {
        guard case .time(let l) = lhs, case .time(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.array, .array): return {
        guard case .array(let l) = lhs, case .array(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.map, .map): return {
        guard case .map(let l) = lhs, case .map(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.any, .any): return {
        guard case .any(let l) = lhs, case .any(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unit, .unit): return {
        guard case .unit(let l) = lhs, case .unit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ref, .ref): return {
        guard case .ref(let l) = lhs, case .ref(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.optional, .optional): return {
        guard case .optional(let l) = lhs, case .optional(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Xyz_Block_Ftl_V1_Schema_TypeAlias {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var comments: [String] = []

  var export: Bool = false

  var name: String = String()

  var type: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _type ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
  fileprivate var _type: Xyz_Block_Ftl_V1_Schema_Type? = nil
}

struct Xyz_Block_Ftl_V1_Schema_TypeParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_TypeValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var value: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _value ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
  fileprivate var _value: Xyz_Block_Ftl_V1_Schema_Type? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Unit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
}

struct Xyz_Block_Ftl_V1_Schema_Value {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Xyz_Block_Ftl_V1_Schema_Value.OneOf_Value? = nil

  var stringValue: Xyz_Block_Ftl_V1_Schema_StringValue {
    get {
      if case .stringValue(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_StringValue()
    }
    set {value = .stringValue(newValue)}
  }

  var intValue: Xyz_Block_Ftl_V1_Schema_IntValue {
    get {
      if case .intValue(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_IntValue()
    }
    set {value = .intValue(newValue)}
  }

  var typeValue: Xyz_Block_Ftl_V1_Schema_TypeValue {
    get {
      if case .typeValue(let v)? = value {return v}
      return Xyz_Block_Ftl_V1_Schema_TypeValue()
    }
    set {value = .typeValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case stringValue(Xyz_Block_Ftl_V1_Schema_StringValue)
    case intValue(Xyz_Block_Ftl_V1_Schema_IntValue)
    case typeValue(Xyz_Block_Ftl_V1_Schema_TypeValue)

  #if !swift(>=4.1)
    static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Value.OneOf_Value, rhs: Xyz_Block_Ftl_V1_Schema_Value.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intValue, .intValue): return {
        guard case .intValue(let l) = lhs, case .intValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.typeValue, .typeValue): return {
        guard case .typeValue(let l) = lhs, case .typeValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Xyz_Block_Ftl_V1_Schema_Verb {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var runtime: Xyz_Block_Ftl_V1_Schema_VerbRuntime {
    get {return _runtime ?? Xyz_Block_Ftl_V1_Schema_VerbRuntime()}
    set {_runtime = newValue}
  }
  /// Returns true if `runtime` has been explicitly set.
  var hasRuntime: Bool {return self._runtime != nil}
  /// Clears the value of `runtime`. Subsequent reads from it will return its default value.
  mutating func clearRuntime() {self._runtime = nil}

  var pos: Xyz_Block_Ftl_V1_Schema_Position {
    get {return _pos ?? Xyz_Block_Ftl_V1_Schema_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  var comments: [String] = []

  var export: Bool = false

  var name: String = String()

  var request: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _request ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  var response: Xyz_Block_Ftl_V1_Schema_Type {
    get {return _response ?? Xyz_Block_Ftl_V1_Schema_Type()}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  mutating func clearResponse() {self._response = nil}

  var metadata: [Xyz_Block_Ftl_V1_Schema_Metadata] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _runtime: Xyz_Block_Ftl_V1_Schema_VerbRuntime? = nil
  fileprivate var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
  fileprivate var _request: Xyz_Block_Ftl_V1_Schema_Type? = nil
  fileprivate var _response: Xyz_Block_Ftl_V1_Schema_Type? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Xyz_Block_Ftl_V1_Schema_Any: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Array: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Bool: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Bytes: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Config: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Data: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Database: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Decl: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Decl.OneOf_Value: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Enum: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_EnumVariant: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Error: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Error.ErrorLevel: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_ErrorList: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_FSM: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_FSMTransition: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Field: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Float: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_IngressPathComponent: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_IngressPathComponent.OneOf_Value: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_IngressPathLiteral: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_IngressPathParameter: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Int: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_IntValue: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Map: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Metadata: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Metadata.OneOf_Value: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_MetadataAlias: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_MetadataCalls: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_MetadataCronJob: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_MetadataDatabases: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_MetadataIngress: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_MetadataRetry: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_MetadataSubscriber: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Module: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Optional: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Position: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Ref: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Schema: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Secret: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_String: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_StringValue: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Subscription: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Time: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Topic: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Type: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Type.OneOf_Value: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_TypeAlias: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_TypeParameter: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_TypeValue: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Unit: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Value: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Value.OneOf_Value: @unchecked Sendable {}
extension Xyz_Block_Ftl_V1_Schema_Verb: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xyz.block.ftl.v1.schema"

extension Xyz_Block_Ftl_V1_Schema_Any: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Any"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Any, rhs: Xyz_Block_Ftl_V1_Schema_Any) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Array: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Array"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "element"),
  ]

  fileprivate class _StorageClass {
    var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
    var _element: Xyz_Block_Ftl_V1_Schema_Type? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _pos = source._pos
      _element = source._element
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._pos) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._element) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._pos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._element {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Array, rhs: Xyz_Block_Ftl_V1_Schema_Array) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pos != rhs_storage._pos {return false}
        if _storage._element != rhs_storage._element {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Bool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Bool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Bool, rhs: Xyz_Block_Ftl_V1_Schema_Bool) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Bytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Bytes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Bytes, rhs: Xyz_Block_Ftl_V1_Schema_Bytes) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Config"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "comments"),
    3: .same(proto: "name"),
    4: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Config, rhs: Xyz_Block_Ftl_V1_Schema_Config) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.name != rhs.name {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "comments"),
    3: .same(proto: "export"),
    4: .same(proto: "name"),
    5: .same(proto: "typeParameters"),
    6: .same(proto: "fields"),
    7: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.export) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.typeParameters) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 2)
    }
    if self.export != false {
      try visitor.visitSingularBoolField(value: self.export, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.typeParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.typeParameters, fieldNumber: 5)
    }
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 6)
    }
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Data, rhs: Xyz_Block_Ftl_V1_Schema_Data) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.export != rhs.export {return false}
    if lhs.name != rhs.name {return false}
    if lhs.typeParameters != rhs.typeParameters {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Database: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Database"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "comments"),
    3: .same(proto: "name"),
    4: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Database, rhs: Xyz_Block_Ftl_V1_Schema_Database) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Decl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Decl"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "verb"),
    3: .same(proto: "database"),
    4: .same(proto: "enum"),
    5: .same(proto: "typeAlias"),
    6: .same(proto: "config"),
    7: .same(proto: "secret"),
    8: .same(proto: "fsm"),
    9: .same(proto: "topic"),
    10: .same(proto: "subscription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xyz_Block_Ftl_V1_Schema_Data?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .data(v)
        }
      }()
      case 2: try {
        var v: Xyz_Block_Ftl_V1_Schema_Verb?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .verb(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .verb(v)
        }
      }()
      case 3: try {
        var v: Xyz_Block_Ftl_V1_Schema_Database?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .database(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .database(v)
        }
      }()
      case 4: try {
        var v: Xyz_Block_Ftl_V1_Schema_Enum?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .enum(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .enum(v)
        }
      }()
      case 5: try {
        var v: Xyz_Block_Ftl_V1_Schema_TypeAlias?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .typeAlias(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .typeAlias(v)
        }
      }()
      case 6: try {
        var v: Xyz_Block_Ftl_V1_Schema_Config?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .config(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .config(v)
        }
      }()
      case 7: try {
        var v: Xyz_Block_Ftl_V1_Schema_Secret?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .secret(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .secret(v)
        }
      }()
      case 8: try {
        var v: Xyz_Block_Ftl_V1_Schema_FSM?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .fsm(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .fsm(v)
        }
      }()
      case 9: try {
        var v: Xyz_Block_Ftl_V1_Schema_Topic?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .topic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .topic(v)
        }
      }()
      case 10: try {
        var v: Xyz_Block_Ftl_V1_Schema_Subscription?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .subscription(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .subscription(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .data?: try {
      guard case .data(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .verb?: try {
      guard case .verb(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .database?: try {
      guard case .database(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .enum?: try {
      guard case .enum(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .typeAlias?: try {
      guard case .typeAlias(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .config?: try {
      guard case .config(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .secret?: try {
      guard case .secret(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .fsm?: try {
      guard case .fsm(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .topic?: try {
      guard case .topic(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .subscription?: try {
      guard case .subscription(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Decl, rhs: Xyz_Block_Ftl_V1_Schema_Decl) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Enum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Enum"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "comments"),
    3: .same(proto: "export"),
    4: .same(proto: "name"),
    5: .same(proto: "type"),
    6: .same(proto: "variants"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.export) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.variants) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 2)
    }
    if self.export != false {
      try visitor.visitSingularBoolField(value: self.export, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.variants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variants, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Enum, rhs: Xyz_Block_Ftl_V1_Schema_Enum) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.export != rhs.export {return false}
    if lhs.name != rhs.name {return false}
    if lhs._type != rhs._type {return false}
    if lhs.variants != rhs.variants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_EnumVariant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnumVariant"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "comments"),
    3: .same(proto: "name"),
    4: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_EnumVariant, rhs: Xyz_Block_Ftl_V1_Schema_EnumVariant) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.name != rhs.name {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "pos"),
    3: .same(proto: "endColumn"),
    4: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.endColumn) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 1)
    }
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.endColumn != 0 {
      try visitor.visitSingularInt64Field(value: self.endColumn, fieldNumber: 3)
    }
    if self.level != .info {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Error, rhs: Xyz_Block_Ftl_V1_Schema_Error) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs._pos != rhs._pos {return false}
    if lhs.endColumn != rhs.endColumn {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Error.ErrorLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INFO"),
    1: .same(proto: "WARN"),
    2: .same(proto: "ERROR"),
  ]
}

extension Xyz_Block_Ftl_V1_Schema_ErrorList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ErrorList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_ErrorList, rhs: Xyz_Block_Ftl_V1_Schema_ErrorList) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_FSM: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FSM"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "comments"),
    3: .same(proto: "name"),
    4: .same(proto: "start"),
    5: .same(proto: "transitions"),
    6: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.start) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.transitions) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.start.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.start, fieldNumber: 4)
    }
    if !self.transitions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transitions, fieldNumber: 5)
    }
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_FSM, rhs: Xyz_Block_Ftl_V1_Schema_FSM) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.name != rhs.name {return false}
    if lhs.start != rhs.start {return false}
    if lhs.transitions != rhs.transitions {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_FSMTransition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FSMTransition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "comments"),
    3: .same(proto: "from"),
    4: .same(proto: "to"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 2)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_FSMTransition, rhs: Xyz_Block_Ftl_V1_Schema_FSMTransition) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Field"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "name"),
    3: .same(proto: "comments"),
    4: .same(proto: "type"),
    5: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 3)
    }
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Field, rhs: Xyz_Block_Ftl_V1_Schema_Field) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.name != rhs.name {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs._type != rhs._type {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Float: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Float"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Float, rhs: Xyz_Block_Ftl_V1_Schema_Float) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_IngressPathComponent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IngressPathComponent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ingressPathLiteral"),
    2: .same(proto: "ingressPathParameter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xyz_Block_Ftl_V1_Schema_IngressPathLiteral?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .ingressPathLiteral(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .ingressPathLiteral(v)
        }
      }()
      case 2: try {
        var v: Xyz_Block_Ftl_V1_Schema_IngressPathParameter?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .ingressPathParameter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .ingressPathParameter(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .ingressPathLiteral?: try {
      guard case .ingressPathLiteral(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ingressPathParameter?: try {
      guard case .ingressPathParameter(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_IngressPathComponent, rhs: Xyz_Block_Ftl_V1_Schema_IngressPathComponent) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_IngressPathLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IngressPathLiteral"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_IngressPathLiteral, rhs: Xyz_Block_Ftl_V1_Schema_IngressPathLiteral) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_IngressPathParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IngressPathParameter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_IngressPathParameter, rhs: Xyz_Block_Ftl_V1_Schema_IngressPathParameter) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Int: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Int"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Int, rhs: Xyz_Block_Ftl_V1_Schema_Int) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_IntValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IntValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_IntValue, rhs: Xyz_Block_Ftl_V1_Schema_IntValue) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Map: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Map"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "key"),
    3: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
    var _key: Xyz_Block_Ftl_V1_Schema_Type? = nil
    var _value: Xyz_Block_Ftl_V1_Schema_Type? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _pos = source._pos
      _key = source._key
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._pos) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._key) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._pos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Map, rhs: Xyz_Block_Ftl_V1_Schema_Map) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pos != rhs_storage._pos {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Metadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "calls"),
    2: .same(proto: "ingress"),
    3: .same(proto: "cronJob"),
    4: .same(proto: "databases"),
    5: .same(proto: "alias"),
    6: .same(proto: "retry"),
    7: .same(proto: "subscriber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xyz_Block_Ftl_V1_Schema_MetadataCalls?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .calls(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .calls(v)
        }
      }()
      case 2: try {
        var v: Xyz_Block_Ftl_V1_Schema_MetadataIngress?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .ingress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .ingress(v)
        }
      }()
      case 3: try {
        var v: Xyz_Block_Ftl_V1_Schema_MetadataCronJob?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .cronJob(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .cronJob(v)
        }
      }()
      case 4: try {
        var v: Xyz_Block_Ftl_V1_Schema_MetadataDatabases?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .databases(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .databases(v)
        }
      }()
      case 5: try {
        var v: Xyz_Block_Ftl_V1_Schema_MetadataAlias?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .alias(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .alias(v)
        }
      }()
      case 6: try {
        var v: Xyz_Block_Ftl_V1_Schema_MetadataRetry?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .retry(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .retry(v)
        }
      }()
      case 7: try {
        var v: Xyz_Block_Ftl_V1_Schema_MetadataSubscriber?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .subscriber(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .subscriber(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .calls?: try {
      guard case .calls(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ingress?: try {
      guard case .ingress(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cronJob?: try {
      guard case .cronJob(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .databases?: try {
      guard case .databases(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .alias?: try {
      guard case .alias(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .retry?: try {
      guard case .retry(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .subscriber?: try {
      guard case .subscriber(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Metadata, rhs: Xyz_Block_Ftl_V1_Schema_Metadata) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_MetadataAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetadataAlias"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "kind"),
    3: .same(proto: "alias"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.kind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.alias) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.kind != 0 {
      try visitor.visitSingularInt64Field(value: self.kind, fieldNumber: 2)
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_MetadataAlias, rhs: Xyz_Block_Ftl_V1_Schema_MetadataAlias) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.alias != rhs.alias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_MetadataCalls: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetadataCalls"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "calls"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.calls) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.calls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.calls, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_MetadataCalls, rhs: Xyz_Block_Ftl_V1_Schema_MetadataCalls) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.calls != rhs.calls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_MetadataCronJob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetadataCronJob"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "cron"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cron) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.cron.isEmpty {
      try visitor.visitSingularStringField(value: self.cron, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_MetadataCronJob, rhs: Xyz_Block_Ftl_V1_Schema_MetadataCronJob) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.cron != rhs.cron {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_MetadataDatabases: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetadataDatabases"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "calls"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.calls) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.calls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.calls, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_MetadataDatabases, rhs: Xyz_Block_Ftl_V1_Schema_MetadataDatabases) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.calls != rhs.calls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_MetadataIngress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetadataIngress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "type"),
    3: .same(proto: "method"),
    4: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.method) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 3)
    }
    if !self.path.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.path, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_MetadataIngress, rhs: Xyz_Block_Ftl_V1_Schema_MetadataIngress) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.type != rhs.type {return false}
    if lhs.method != rhs.method {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_MetadataRetry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetadataRetry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "count"),
    3: .same(proto: "minBackoff"),
    4: .same(proto: "maxBackoff"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._count) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.minBackoff) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.maxBackoff) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._count {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.minBackoff.isEmpty {
      try visitor.visitSingularStringField(value: self.minBackoff, fieldNumber: 3)
    }
    if !self.maxBackoff.isEmpty {
      try visitor.visitSingularStringField(value: self.maxBackoff, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_MetadataRetry, rhs: Xyz_Block_Ftl_V1_Schema_MetadataRetry) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs._count != rhs._count {return false}
    if lhs.minBackoff != rhs.minBackoff {return false}
    if lhs.maxBackoff != rhs.maxBackoff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_MetadataSubscriber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetadataSubscriber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_MetadataSubscriber, rhs: Xyz_Block_Ftl_V1_Schema_MetadataSubscriber) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Module: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Module"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    31634: .same(proto: "runtime"),
    1: .same(proto: "pos"),
    2: .same(proto: "comments"),
    3: .same(proto: "builtin"),
    4: .same(proto: "name"),
    5: .same(proto: "decls"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.builtin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.decls) }()
      case 31634: try { try decoder.decodeSingularMessageField(value: &self._runtime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 2)
    }
    if self.builtin != false {
      try visitor.visitSingularBoolField(value: self.builtin, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.decls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.decls, fieldNumber: 5)
    }
    try { if let v = self._runtime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31634)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Module, rhs: Xyz_Block_Ftl_V1_Schema_Module) -> Bool {
    if lhs._runtime != rhs._runtime {return false}
    if lhs._pos != rhs._pos {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.builtin != rhs.builtin {return false}
    if lhs.name != rhs.name {return false}
    if lhs.decls != rhs.decls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Optional: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Optional"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "type"),
  ]

  fileprivate class _StorageClass {
    var _pos: Xyz_Block_Ftl_V1_Schema_Position? = nil
    var _type: Xyz_Block_Ftl_V1_Schema_Type? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _pos = source._pos
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._pos) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._type) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._pos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Optional, rhs: Xyz_Block_Ftl_V1_Schema_Optional) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pos != rhs_storage._pos {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Position"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .same(proto: "line"),
    3: .same(proto: "column"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.line) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.column) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 1)
    }
    if self.line != 0 {
      try visitor.visitSingularInt64Field(value: self.line, fieldNumber: 2)
    }
    if self.column != 0 {
      try visitor.visitSingularInt64Field(value: self.column, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Position, rhs: Xyz_Block_Ftl_V1_Schema_Position) -> Bool {
    if lhs.filename != rhs.filename {return false}
    if lhs.line != rhs.line {return false}
    if lhs.column != rhs.column {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Ref: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ref"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "name"),
    3: .same(proto: "module"),
    4: .same(proto: "typeParameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.module) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.typeParameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.module.isEmpty {
      try visitor.visitSingularStringField(value: self.module, fieldNumber: 3)
    }
    if !self.typeParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.typeParameters, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Ref, rhs: Xyz_Block_Ftl_V1_Schema_Ref) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.name != rhs.name {return false}
    if lhs.module != rhs.module {return false}
    if lhs.typeParameters != rhs.typeParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Schema: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Schema"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "modules"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.modules) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modules, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Schema, rhs: Xyz_Block_Ftl_V1_Schema_Schema) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.modules != rhs.modules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Secret: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Secret"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "comments"),
    3: .same(proto: "name"),
    4: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Secret, rhs: Xyz_Block_Ftl_V1_Schema_Secret) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.name != rhs.name {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_String: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".String"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_String, rhs: Xyz_Block_Ftl_V1_Schema_String) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_StringValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_StringValue, rhs: Xyz_Block_Ftl_V1_Schema_StringValue) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Subscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Subscription"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "comments"),
    3: .same(proto: "name"),
    4: .same(proto: "topic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._topic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try { if let v = self._topic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Subscription, rhs: Xyz_Block_Ftl_V1_Schema_Subscription) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.name != rhs.name {return false}
    if lhs._topic != rhs._topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Time: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Time"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Time, rhs: Xyz_Block_Ftl_V1_Schema_Time) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Topic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Topic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "comments"),
    3: .same(proto: "export"),
    4: .same(proto: "name"),
    5: .same(proto: "event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.export) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 2)
    }
    if self.export != false {
      try visitor.visitSingularBoolField(value: self.export, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Topic, rhs: Xyz_Block_Ftl_V1_Schema_Topic) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.export != rhs.export {return false}
    if lhs.name != rhs.name {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Type: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Type"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "int"),
    2: .same(proto: "float"),
    3: .same(proto: "string"),
    4: .same(proto: "bytes"),
    5: .same(proto: "bool"),
    6: .same(proto: "time"),
    7: .same(proto: "array"),
    8: .same(proto: "map"),
    9: .same(proto: "any"),
    10: .same(proto: "unit"),
    11: .same(proto: "ref"),
    12: .same(proto: "optional"),
  ]

  fileprivate class _StorageClass {
    var _value: Xyz_Block_Ftl_V1_Schema_Type.OneOf_Value?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Xyz_Block_Ftl_V1_Schema_Int?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .int(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .int(v)
          }
        }()
        case 2: try {
          var v: Xyz_Block_Ftl_V1_Schema_Float?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .float(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .float(v)
          }
        }()
        case 3: try {
          var v: Xyz_Block_Ftl_V1_Schema_String?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .string(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .string(v)
          }
        }()
        case 4: try {
          var v: Xyz_Block_Ftl_V1_Schema_Bytes?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .bytes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .bytes(v)
          }
        }()
        case 5: try {
          var v: Xyz_Block_Ftl_V1_Schema_Bool?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .bool(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .bool(v)
          }
        }()
        case 6: try {
          var v: Xyz_Block_Ftl_V1_Schema_Time?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .time(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .time(v)
          }
        }()
        case 7: try {
          var v: Xyz_Block_Ftl_V1_Schema_Array?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .array(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .array(v)
          }
        }()
        case 8: try {
          var v: Xyz_Block_Ftl_V1_Schema_Map?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .map(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .map(v)
          }
        }()
        case 9: try {
          var v: Xyz_Block_Ftl_V1_Schema_Any?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .any(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .any(v)
          }
        }()
        case 10: try {
          var v: Xyz_Block_Ftl_V1_Schema_Unit?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .unit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .unit(v)
          }
        }()
        case 11: try {
          var v: Xyz_Block_Ftl_V1_Schema_Ref?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .ref(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .ref(v)
          }
        }()
        case 12: try {
          var v: Xyz_Block_Ftl_V1_Schema_Optional?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .optional(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .optional(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._value {
      case .int?: try {
        guard case .int(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .float?: try {
        guard case .float(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .string?: try {
        guard case .string(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .bytes?: try {
        guard case .bytes(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .bool?: try {
        guard case .bool(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .time?: try {
        guard case .time(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .array?: try {
        guard case .array(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .map?: try {
        guard case .map(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .any?: try {
        guard case .any(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .unit?: try {
        guard case .unit(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .ref?: try {
        guard case .ref(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .optional?: try {
        guard case .optional(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Type, rhs: Xyz_Block_Ftl_V1_Schema_Type) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_TypeAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypeAlias"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "comments"),
    3: .same(proto: "export"),
    4: .same(proto: "name"),
    5: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.export) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 2)
    }
    if self.export != false {
      try visitor.visitSingularBoolField(value: self.export, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_TypeAlias, rhs: Xyz_Block_Ftl_V1_Schema_TypeAlias) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.export != rhs.export {return false}
    if lhs.name != rhs.name {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_TypeParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypeParameter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_TypeParameter, rhs: Xyz_Block_Ftl_V1_Schema_TypeParameter) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_TypeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypeValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_TypeValue, rhs: Xyz_Block_Ftl_V1_Schema_TypeValue) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Unit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Unit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Unit, rhs: Xyz_Block_Ftl_V1_Schema_Unit) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Value"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stringValue"),
    2: .same(proto: "intValue"),
    3: .same(proto: "typeValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xyz_Block_Ftl_V1_Schema_StringValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .stringValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .stringValue(v)
        }
      }()
      case 2: try {
        var v: Xyz_Block_Ftl_V1_Schema_IntValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .intValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .intValue(v)
        }
      }()
      case 3: try {
        var v: Xyz_Block_Ftl_V1_Schema_TypeValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .typeValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .typeValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .intValue?: try {
      guard case .intValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .typeValue?: try {
      guard case .typeValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Value, rhs: Xyz_Block_Ftl_V1_Schema_Value) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xyz_Block_Ftl_V1_Schema_Verb: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Verb"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    31634: .same(proto: "runtime"),
    1: .same(proto: "pos"),
    2: .same(proto: "comments"),
    3: .same(proto: "export"),
    4: .same(proto: "name"),
    5: .same(proto: "request"),
    6: .same(proto: "response"),
    7: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.export) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._response) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      case 31634: try { try decoder.decodeSingularMessageField(value: &self._runtime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 2)
    }
    if self.export != false {
      try visitor.visitSingularBoolField(value: self.export, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 7)
    }
    try { if let v = self._runtime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31634)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Xyz_Block_Ftl_V1_Schema_Verb, rhs: Xyz_Block_Ftl_V1_Schema_Verb) -> Bool {
    if lhs._runtime != rhs._runtime {return false}
    if lhs._pos != rhs._pos {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.export != rhs.export {return false}
    if lhs.name != rhs.name {return false}
    if lhs._request != rhs._request {return false}
    if lhs._response != rhs._response {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
