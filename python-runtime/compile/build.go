package compile

import (
	"context"
	"fmt"
	"os"
	"path"
	"path/filepath"
	stdreflect "reflect"
	"strconv"
	"strings"

	"github.com/block/scaffolder"
	"google.golang.org/protobuf/proto"

	schemapb "github.com/TBD54566975/ftl/backend/protos/xyz/block/ftl/schema/v1"
	"github.com/TBD54566975/ftl/internal"
	"github.com/TBD54566975/ftl/internal/builderrors"
	"github.com/TBD54566975/ftl/internal/exec"
	"github.com/TBD54566975/ftl/internal/log"
	"github.com/TBD54566975/ftl/internal/moduleconfig"
	"github.com/TBD54566975/ftl/internal/schema"
	"github.com/TBD54566975/ftl/internal/schema/strcase"
)

type mainDeploymentContext struct {
	Name string
}

const buildDirName = ".ftl"

func buildDir(moduleDir string) string {
	return filepath.Join(moduleDir, buildDirName)
}

func Build(ctx context.Context, projectRootDir, stubsRoot string, config moduleconfig.AbsModuleConfig, sch *schema.Schema, buildEnv []string, devMode bool) (moduleSch *schema.Module, buildErrors []builderrors.Error, err error) {
	// TODO: add ModifyFilesTransaction
	logger := log.FromContext(ctx)
	logger.Debugf("Generating python main module")

	mctx := mainDeploymentContext{
		Name: config.Module,
	}

	buildDir := buildDir(config.Dir)

	// Execute the Python schema extractor
	if err := exec.Command(ctx, log.Debug, config.Dir, "uv", "run", "-m", "ftl.cli.schema_extractor", ".").RunBuffered(ctx); err != nil {
		return nil, nil, fmt.Errorf("failed to extract schema: %w", err)
	}

	outputFile := filepath.Join(buildDir, "schema.pb")
	serializedData, err := os.ReadFile(outputFile)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read serialized schema: %w", err)
	}

	var modulepb schemapb.Module
	err = proto.Unmarshal(serializedData, &modulepb)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to unmarshal module proto: %w", err)
	}

	module, err := schema.ModuleFromProto(&modulepb)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to deserialize module schema: %w", err)
	}

	if err := internal.ScaffoldZip(buildTemplateFiles(), buildDir, mctx, scaffolder.Functions(scaffoldFuncs)); err != nil {
		return moduleSch, nil, fmt.Errorf("failed to scaffold build template: %w", err)
	}

	return module, nil, nil
}

var scaffoldFuncs = scaffolder.FuncMap{
	"comment": encodeComments,
	"type":    genType,
	"is": func(kind string, t schema.Node) bool {
		return stdreflect.Indirect(stdreflect.ValueOf(t)).Type().Name() == kind
	},
	"imports": imports,
	"value": func(v schema.Value) string {
		switch t := v.(type) {
		case *schema.StringValue:
			return fmt.Sprintf("%q", t.Value)
		case *schema.IntValue:
			return strconv.Itoa(t.Value)
		case *schema.TypeValue:
			return t.Value.String()
		}
		panic(fmt.Sprintf("unsupported value %T", v))
	},
	"sumTypes": func(m *schema.Module) []*schema.Enum {
		out := []*schema.Enum{}
		for _, d := range m.Decls {
			switch d := d.(type) {
			// Type enums (i.e. sum types) are all the non-value enums
			case *schema.Enum:
				if !d.IsValueEnum() && d.IsExported() {
					out = append(out, d)
				}
			default:
			}
		}
		return out
	},
	"typeAliasType": func(m *schema.Module, t *schema.TypeAlias) string {
		for _, md := range t.Metadata {
			md, ok := md.(*schema.MetadataTypeMap)
			if !ok || md.Runtime != "go" {
				continue
			}
			nt, err := nativeTypeFromQualifiedName(md.NativeName)
			if err != nil {
				return ""
			}
			return fmt.Sprintf("%s.%s", nt.pkg, nt.Name)
		}
		return genType(m, t.Type)
	},
	"snakeCase": strcase.ToLowerSnake,
}

func encodeComments(comments []string) string {
	if len(comments) == 0 {
		return ""
	}

	w := &strings.Builder{}
	for _, c := range comments {
		if c == "Code generated by FTL. DO NOT EDIT." {
			continue
		}
		space := ""
		// Empty lines should not have a trailing space.
		if c != "" {
			space = " "
		}

		fmt.Fprintf(w, "# %s%s\n", space, c)
	}
	return w.String()
}

func genType(module *schema.Module, t schema.Type) string {
	switch t := t.(type) {
	case *schema.Ref:
		return t.Name

	case *schema.Float:
		return "float"

	case *schema.Time:
		return "datetime.datetime"

	case *schema.Int, *schema.Bool:
		return strings.ToLower(t.String())

	case *schema.String:
		return "str"

	case *schema.Array:
		return "List[" + genType(module, t.Element) + "]"

	case *schema.Map:
		return "Dict[" + genType(module, t.Value) + "]" + genType(module, t.Value)

	case *schema.Optional:
		return "Optional[" + genType(module, t.Type) + "]"

	case *schema.Unit:
		return "None"

	case *schema.Any:
		return "Any"

	case *schema.Bytes:
		return "bytes"
	}
	panic(fmt.Sprintf("unsupported type %T", t))
}

func imports(m *schema.Module) map[string]string {
	// find all imports
	imports := map[string]string{}
	_ = schema.VisitExcludingMetadataChildren(m, func(n schema.Node, next func() error) error { //nolint:errcheck
		switch n := n.(type) {
		case *schema.Ref:
			imports[path.Join("ftl", n.Module)] = "ftl" + n.Module
			for _, tp := range n.TypeParameters {
				if tpRef, ok := tp.(*schema.Ref); ok && tpRef.Module != "" && tpRef.Module != m.Name {
					imports[path.Join("ftl", tpRef.Module)] = "ftl" + tpRef.Module
				}
			}

		// Will need more imports here for standard types
		default:
		}
		return next()
	})

	return imports
}

type nativeType struct {
	Name        string
	pkg         string
	ImportPath  string
	ImportAlias bool
}

func nativeTypeFromQualifiedName(qualifiedName string) (nativeType, error) {
	lastDotIndex := strings.LastIndex(qualifiedName, ".")
	if lastDotIndex == -1 {
		return nativeType{}, fmt.Errorf("invalid qualified type format %q", qualifiedName)
	}

	pkgPath := qualifiedName[:lastDotIndex]
	typeName := qualifiedName[lastDotIndex+1:]
	pkgName := path.Base(pkgPath)
	aliased := false

	// Handle package aliasing by checking for additional dots in the package name
	if strings.LastIndex(pkgName, ".") != -1 {
		lastDotIndex = strings.LastIndex(pkgPath, ".")
		pkgName = pkgPath[lastDotIndex+1:]
		pkgPath = pkgPath[:lastDotIndex]
		aliased = true
	}

	// Check if the qualified name has a Pythonic prefix like "ftl" and modify the package name
	if parts := strings.Split(qualifiedName, "/"); len(parts) > 0 && parts[0] == "ftl" {
		aliased = true
		pkgName = "ftl_" + pkgName // Python typically uses underscores instead of dots for naming
	}

	// Construct the Python native type structure
	return nativeType{
		Name:        typeName,                              // This would be the class name or type in Python
		pkg:         pkgName,                               // The Python package name
		ImportPath:  strings.ReplaceAll(pkgPath, ".", "/"), // Python uses '/' for import paths instead of '.'
		ImportAlias: aliased,                               // Indicates if it's an aliased import
	}, nil
}
