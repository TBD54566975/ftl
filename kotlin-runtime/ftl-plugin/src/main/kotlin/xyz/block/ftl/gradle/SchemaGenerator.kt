package xyz.block.ftl.gradle

import com.squareup.kotlinpoet.*
import com.squareup.wire.GrpcClient
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.ReceiveChannel
import kotlinx.coroutines.channels.SendChannel
import okhttp3.OkHttpClient
import okhttp3.Protocol
import org.gradle.configurationcache.extensions.capitalized
import xyz.block.ftl.v1.ControllerServiceClient
import xyz.block.ftl.v1.PullSchemaRequest
import xyz.block.ftl.v1.PullSchemaResponse
import xyz.block.ftl.v1.schema.Type
import java.time.Duration

class SchemaGenerator(ftlEndpoint: String) {
  private var grpcClient: GrpcClient
  private lateinit var sendSchemaChannel: SendChannel<PullSchemaRequest>
  private lateinit var receiveSchemaChannel: ReceiveChannel<PullSchemaResponse>

  init {
    grpcClient = GrpcClient.Builder()
      .client(
        OkHttpClient.Builder()
          .readTimeout(Duration.ofSeconds(10))
          .writeTimeout(Duration.ofSeconds(10))
          .callTimeout(Duration.ofSeconds(10))
          .protocols(listOf(Protocol.H2_PRIOR_KNOWLEDGE))
          .build()
      )
      .baseUrl(ftlEndpoint)
      .build()
  }

  fun generate() {
    runBlocking {
      launch {
        grpcClient.create(ControllerServiceClient::class)
          .PullSchema()
          .executeIn(this)
          .let { (sendChannel, receiveChannel) ->
            sendSchemaChannel = sendChannel
            receiveSchemaChannel = receiveChannel
          }

        require(sendSchemaChannel.trySend(PullSchemaRequest()).isSuccess)
        try {
          for (schema in receiveSchemaChannel) {
            generateModule(schema)
            if (!schema.more) {
              receiveSchemaChannel.cancel()
              return@launch
            }
          }
        } catch (e: Exception) {
          receiveSchemaChannel.cancel()
          throw e
        }
      }
    }
  }

  private fun generateModule(schema: PullSchemaResponse) {
    val file = FileSpec.builder("ftl.${schema.module_name}", schema.module_name.capitalized())
      .addFileComment("Generated by FTL-Plugin")

    val klass = TypeSpec.classBuilder(schema.module_name.capitalized())
      .primaryConstructor(
        FunSpec.constructorBuilder()
          .build()
      )

    val verbs = schema.schema?.decls?.mapNotNull { it.verb } ?: listOf()
    val types = schema.schema?.decls?.mapNotNull { it.data_ } ?: listOf()

    types.forEach { type ->
      val dataClassBuilder = TypeSpec.classBuilder(type.name)
        .addModifiers(KModifier.DATA)
        .addKdoc(type.comments.joinToString("\n"))

      val constructorBuilder = FunSpec.constructorBuilder()
      type.fields.forEach { field ->
        dataClassBuilder.addKdoc(field.comments.joinToString("\n"))
        field.type?.let {
          val typeName = TypeVariableName(getTypeName(it).replace("{}", ""))
          constructorBuilder.addParameter(field.name, typeName)
          dataClassBuilder.addProperty(
              PropertySpec.builder(field.name, typeName)
                .initializer(field.name)
                .build()
            )
        }
      }

      dataClassBuilder.primaryConstructor(
        constructorBuilder
          .build()
      )

      file.addType(
        dataClassBuilder.build()
      )
    }

    verbs.forEach { verb ->
      val funSpecBuilder = FunSpec.builder(verb.name)
        .addKdoc(verb.comments.joinToString("\n"))
        .addAnnotation(
          AnnotationSpec.builder(ClassName("xyz.block.ftl", "Verb"))
            .build()
        )
        .addCode("throw NotImplementedError()")
      verb.metadata.forEach { metadata ->
        metadata.ingress?.let {
            funSpecBuilder.addAnnotation(
              AnnotationSpec.builder(ClassName("xyz.block.ftl", "Ingress"))
                .addMember("%T", ClassName("xyz.block.ftl.Method", it.method))
                .addMember("%S", it.path)
                .build()
            )
        }
      }

      verb.request?.let {
        funSpecBuilder.addParameter(
          "req",
          TypeVariableName(it.name)
        )
      }
      verb.response?.let {
        funSpecBuilder.returns(
          TypeVariableName(it.name)
        )
      }

      klass.addFunction(
        funSpecBuilder.build()
      )
    }

    file.addType(klass.build())
    file.build().writeTo(System.out)
  }

  // TODO(wes): Is there a better way to get the type from this schema?
  private fun getTypeName(typeInstance: Type): String {
    return when {
      typeInstance.int != null -> typeInstance.int.toString()
      typeInstance.float != null -> typeInstance.float.toString()
      typeInstance.string != null -> typeInstance.string.toString()
      typeInstance.bool != null -> typeInstance.bool.toString()
      typeInstance.time != null -> typeInstance.time.toString()
      typeInstance.array != null -> typeInstance.array.toString()
      typeInstance.map != null -> typeInstance.map.toString()
      typeInstance.verbRef != null -> typeInstance.verbRef.toString()
      typeInstance.dataRef != null -> typeInstance.dataRef.toString()

      else -> throw IllegalArgumentException("Unknown value")
    }
  }
}
