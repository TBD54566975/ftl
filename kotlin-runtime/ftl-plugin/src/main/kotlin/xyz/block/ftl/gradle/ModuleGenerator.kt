package xyz.block.ftl.gradle

import com.squareup.kotlinpoet.*
import org.gradle.configurationcache.extensions.capitalized
import xyz.block.ftl.v1.PullSchemaResponse
import xyz.block.ftl.v1.schema.Data
import xyz.block.ftl.v1.schema.Type
import xyz.block.ftl.v1.schema.Verb
import java.io.File

class ModuleGenerator() {
  fun run(schemas: List<PullSchemaResponse>, outputDirectory: File, module: String) {
    schemas.filter { it.module_name != module }.forEach { generateModule(it, outputDirectory, module) }
  }

  private fun generateModule(schema: PullSchemaResponse, outputDirectory: File, module: String) {
    val namespace = "ftl.$module"
    val className = schema.module_name.capitalized()
    val file = FileSpec.builder(namespace, className)
      .addFileComment("Generated by FTL-Plugin")

    val moduleClass = TypeSpec.classBuilder(className)
      .primaryConstructor(
        FunSpec.constructorBuilder()
          .build()
      )

    val types = schema.schema?.decls?.mapNotNull { it.data_ } ?: listOf()
    types.forEach { file.addType(buildDataClass(it)) }

    val verbs = schema.schema?.decls?.mapNotNull { it.verb } ?: listOf()
    verbs.forEach { moduleClass.addFunction(buildVerbFunction(it)) }

    file.addType(moduleClass.build())
    file.build().writeTo(outputDirectory)
    println("Generated module: ${outputDirectory.absolutePath}/${namespace.replace(".", "/")}/$className.kt")
  }

  private fun buildDataClass(type: Data): TypeSpec {
    val dataClassBuilder = TypeSpec.classBuilder(type.name)
      .addModifiers(KModifier.DATA)
      .addKdoc(type.comments.joinToString("\n"))

    val dataConstructorBuilder = FunSpec.constructorBuilder()
    type.fields.forEach { field ->
      dataClassBuilder.addKdoc(field.comments.joinToString("\n"))
      field.type?.let {
        val typeName = TypeVariableName(getTypeName(it).replace("{}", ""))
        dataConstructorBuilder.addParameter(field.name, typeName)
        dataClassBuilder.addProperty(
          PropertySpec.builder(field.name, typeName)
            .initializer(field.name)
            .build()
        )
      }
    }

    // Handle empty data classes.
    if (type.fields.isEmpty()) {
      dataConstructorBuilder
        .addParameter(
          ParameterSpec.builder("_empty", Unit::class)
            .defaultValue("Unit")
            .build()
        )
      dataClassBuilder.addProperty(
        PropertySpec.builder("_empty", Unit::class)
          .initializer("_empty")
          .build()
      )
    }

    dataClassBuilder.primaryConstructor(dataConstructorBuilder.build())

    return dataClassBuilder.build()
  }

  private fun buildVerbFunction(verb: Verb): FunSpec {
    val verbFunBuilder = FunSpec.builder(verb.name)
      .addKdoc(verb.comments.joinToString("\n"))
      .addAnnotation(
        AnnotationSpec.builder(ClassName("xyz.block.ftl", "Verb"))
          .build()
      )

    verb.metadata.forEach { metadata ->
      metadata.ingress?.let {
        verbFunBuilder.addAnnotation(
          AnnotationSpec.builder(ClassName("xyz.block.ftl", "Ingress"))
            .addMember("%T", ClassName("xyz.block.ftl.Method", it.method))
            .addMember("%S", it.path)
            .build()
        )
      }
    }

    verb.request?.let {
      verbFunBuilder.addParameter(
        "req",
        TypeVariableName(it.name)
      )
    }

    verb.response?.let {
      verbFunBuilder.returns(TypeVariableName(it.name))
    }

    val noDirectCalls = "Verb stubs should not be called directly, instead use sdk.Call()"
    verbFunBuilder
      .addComment(noDirectCalls)
      .addCode(
        """throw NotImplementedError("$noDirectCalls")""".trimIndent()
      )

    return verbFunBuilder.build()
  }

  // TODO(wes): Is there a better way to get the type from this schema?
  private fun getTypeName(typeInstance: Type): String {
    return when {
      typeInstance.int != null -> typeInstance.int.toString()
      typeInstance.float != null -> typeInstance.float.toString()
      typeInstance.string != null -> typeInstance.string.toString()
      typeInstance.bool != null -> typeInstance.bool.toString()
      typeInstance.time != null -> typeInstance.time.toString()
      typeInstance.array != null -> typeInstance.array.toString()
      typeInstance.map != null -> typeInstance.map.toString()
      typeInstance.verbRef != null -> typeInstance.verbRef.toString()
      typeInstance.dataRef != null -> typeInstance.dataRef.toString()

      else -> throw IllegalArgumentException("Unknown value")
    }
  }
}
