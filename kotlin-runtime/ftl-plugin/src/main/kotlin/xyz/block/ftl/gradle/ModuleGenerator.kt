package xyz.block.ftl.gradle

import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.TypeVariableName
import org.gradle.configurationcache.extensions.capitalized
import xyz.block.ftl.Context
import xyz.block.ftl.Ignore
import xyz.block.ftl.Ingress
import xyz.block.ftl.v1.PullSchemaResponse
import xyz.block.ftl.v1.schema.Data
import xyz.block.ftl.v1.schema.Type
import xyz.block.ftl.v1.schema.Verb
import java.io.File

class ModuleGenerator() {
  fun run(schemas: List<PullSchemaResponse>, outputDirectory: File, module: String) {
    schemas.filter { it.module_name != module }
      .forEach {
        generateModule(it, outputDirectory)
      }
  }

  private fun generateModule(schema: PullSchemaResponse, outputDirectory: File) {
    val namespace = "ftl.${schema.module_name}"
    val className = schema.module_name.capitalized()
    val file = FileSpec.builder(namespace, className)
      .addFileComment("Generated by FTL-Plugin")

    val moduleClass = TypeSpec.classBuilder(className)
      .addAnnotation(AnnotationSpec.builder(Ignore::class).build())
      .primaryConstructor(
        FunSpec.constructorBuilder()
          .build()
      )

    val types = schema.schema?.decls?.mapNotNull { it.data_ } ?: listOf()
    types.forEach { file.addType(buildDataClass(it)) }

    val verbs = schema.schema?.decls?.mapNotNull { it.verb } ?: listOf()
    verbs.forEach { moduleClass.addFunction(buildVerbFunction(className, it)) }

    file.addType(moduleClass.build())
    file.build().writeTo(outputDirectory)
    println(
      "Generated module: ${outputDirectory.absolutePath}/${
        namespace.replace(
          ".",
          "/"
        )
      }/$className.kt"
    )
  }

  private fun buildDataClass(type: Data): TypeSpec {
    val dataClassBuilder = TypeSpec.classBuilder(type.name)
      .addModifiers(KModifier.DATA)
      .addKdoc(type.comments.joinToString("\n"))

    val dataConstructorBuilder = FunSpec.constructorBuilder()
    type.fields.forEach { field ->
      dataClassBuilder.addKdoc(field.comments.joinToString("\n"))
      field.type?.let {
        val typeName = TypeVariableName(getTypeName(it).replace("{}", ""))
        dataConstructorBuilder.addParameter(field.name, typeName)
        dataClassBuilder.addProperty(
          PropertySpec.builder(field.name, typeName)
            .initializer(field.name)
            .build()
        )
      }
    }

    // Handle empty data classes.
    if (type.fields.isEmpty()) {
      dataConstructorBuilder
        .addParameter(
          ParameterSpec.builder("_empty", Unit::class)
            .defaultValue("Unit")
            .build()
        )
      dataClassBuilder.addProperty(
        PropertySpec.builder("_empty", Unit::class)
          .initializer("_empty")
          .build()
      )
    }

    dataClassBuilder.primaryConstructor(dataConstructorBuilder.build())

    return dataClassBuilder.build()
  }

  private fun buildVerbFunction(className: String, verb: Verb): FunSpec {
    val verbFunBuilder = FunSpec.builder(verb.name)
      .addKdoc(verb.comments.joinToString("\n"))
      .addAnnotation(
        AnnotationSpec.builder(xyz.block.ftl.Verb::class)
          .build()
      )

    verb.metadata.forEach { metadata ->
      metadata.ingress?.let {
        verbFunBuilder.addAnnotation(
          AnnotationSpec.builder(Ingress::class)
            .// TODO(wesb): This was codegenning just the class name, not the enum field.
            addMember("%T", ClassName("xyz.block.ftl.Method", it.method))
            .addMember("%S", it.path)
            .build()
        )
      }
    }

    verbFunBuilder.addParameter("context", Context::class)

    verb.request?.let {
      verbFunBuilder.addParameter(
        "req",
        TypeVariableName(it.name)
      )
    }

    verb.response?.let {
      verbFunBuilder.returns(TypeVariableName(it.name))
    }

    val message =
      "Verb stubs should not be called directly, instead use context.call($className::${verb.name}, ...)"
    verbFunBuilder
      .addCode("""throw NotImplementedError(%S)""", message)

    return verbFunBuilder.build()
  }

  // TODO(wes): Is there a better way to get the type from this schema?
  private fun getTypeName(typeInstance: Type): String {
    return when {
      typeInstance.int != null -> typeInstance.int.toString()
      typeInstance.float != null -> typeInstance.float.toString()
      typeInstance.string != null -> typeInstance.string.toString()
      typeInstance.bool != null -> typeInstance.bool.toString()
      typeInstance.time != null -> typeInstance.time.toString()
      typeInstance.array != null -> typeInstance.array.toString()
      typeInstance.map != null -> typeInstance.map.toString()
      typeInstance.verbRef != null -> typeInstance.verbRef.toString()
      typeInstance.dataRef != null -> typeInstance.dataRef.toString()

      else -> throw IllegalArgumentException("Unknown value")
    }
  }
}
