package xyz.block.ftl.gradle

import com.squareup.kotlinpoet.*
import org.gradle.configurationcache.extensions.capitalized
import xyz.block.ftl.v1.PullSchemaResponse
import xyz.block.ftl.v1.schema.Type
import java.io.File

class ModuleGenerator() {
  fun run(schemas: List<PullSchemaResponse>, outputDirectory: File, module: String) {
    schemas.filter { it.module_name != module }.forEach { generateModule(it, outputDirectory, module) }
    println("Stubs have been successfully generated in the '$outputDirectory' directory for the '$module' module.")
  }

  private fun generateModule(schema: PullSchemaResponse, outputDirectory: File, module: String) {
    val file = FileSpec.builder("ftl.$module", schema.module_name.capitalized())
      .addFileComment("Generated by FTL-Plugin")

    val klass = TypeSpec.classBuilder(schema.module_name.capitalized())
      .primaryConstructor(
        FunSpec.constructorBuilder()
          .build()
      )

    val verbs = schema.schema?.decls?.mapNotNull { it.verb } ?: listOf()
    val types = schema.schema?.decls?.mapNotNull { it.data_ } ?: listOf()

    types.forEach { type ->
      val dataClassBuilder = TypeSpec.classBuilder(type.name)
        .addModifiers(KModifier.DATA)
        .addKdoc(type.comments.joinToString("\n"))

      val constructorBuilder = FunSpec.constructorBuilder()
      type.fields.forEach { field ->
        dataClassBuilder.addKdoc(field.comments.joinToString("\n"))
        field.type?.let {
          val typeName = TypeVariableName(getTypeName(it).replace("{}", ""))
          constructorBuilder.addParameter(field.name, typeName)
          dataClassBuilder.addProperty(
            PropertySpec.builder(field.name, typeName)
              .initializer(field.name)
              .build()
          )
        }
      }

      // Handle empty data classes.
      if (type.fields.isEmpty()) {
        constructorBuilder
          .addParameter(
            ParameterSpec.builder("_empty", Unit::class)
              .defaultValue("Unit")
              .build()
          )
        dataClassBuilder.addProperty(
          PropertySpec.builder("_empty", Unit::class)
            .initializer("_empty")
            .build()
        )
      }

      dataClassBuilder.primaryConstructor(
        constructorBuilder
          .build()
      )

      file.addType(
        dataClassBuilder.build()
      )
    }

    verbs.forEach { verb ->
      val funSpecBuilder = FunSpec.builder(verb.name)
        .addKdoc(verb.comments.joinToString("\n"))
        .addAnnotation(
          AnnotationSpec.builder(ClassName("xyz.block.ftl", "Verb"))
            .build()
        )
        .addCode("""
throw NotImplementedError("Verb stubs should not be called directly, instead use sdk.Call()")""")

      verb.metadata.forEach { metadata ->
        metadata.ingress?.let {
          funSpecBuilder.addAnnotation(
            AnnotationSpec.builder(ClassName("xyz.block.ftl", "Ingress"))
              .addMember("%T", ClassName("xyz.block.ftl.Method", it.method))
              .addMember("%S", it.path)
              .build()
          )
        }
      }

      verb.request?.let {
        funSpecBuilder.addParameter(
          "req",
          TypeVariableName(it.name)
        )
      }
      verb.response?.let {
        funSpecBuilder.returns(
          TypeVariableName(it.name)
        )
      }

      klass.addFunction(
        funSpecBuilder.build()
      )
    }

    file.addType(klass.build())
    file.build().writeTo(outputDirectory)
  }

  // TODO(wes): Is there a better way to get the type from this schema?
  private fun getTypeName(typeInstance: Type): String {
    return when {
      typeInstance.int != null -> typeInstance.int.toString()
      typeInstance.float != null -> typeInstance.float.toString()
      typeInstance.string != null -> typeInstance.string.toString()
      typeInstance.bool != null -> typeInstance.bool.toString()
      typeInstance.time != null -> typeInstance.time.toString()
      typeInstance.array != null -> typeInstance.array.toString()
      typeInstance.map != null -> typeInstance.map.toString()
      typeInstance.verbRef != null -> typeInstance.verbRef.toString()
      typeInstance.dataRef != null -> typeInstance.dataRef.toString()

      else -> throw IllegalArgumentException("Unknown value")
    }
  }
}
