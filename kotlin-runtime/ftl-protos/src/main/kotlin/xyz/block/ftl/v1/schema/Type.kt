// Code generated by Wire protocol buffer compiler, do not edit.
// Source: xyz.block.ftl.v1.schema.Type in xyz/block/ftl/v1/schema/schema.proto
package xyz.block.ftl.v1.schema

import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.ReverseProtoWriter
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireField
import com.squareup.wire.`internal`.countNonNull
import kotlin.Any
import kotlin.AssertionError
import kotlin.Boolean
import kotlin.Deprecated
import kotlin.DeprecationLevel
import kotlin.Long
import kotlin.Nothing
import kotlin.Unit
import kotlin.jvm.JvmField
import okio.ByteString

public class Type(
  @field:WireField(
    tag = 1,
    adapter = "xyz.block.ftl.v1.schema.Int#ADAPTER",
    oneofName = "value",
  )
  public val int: Int? = null,
  @field:WireField(
    tag = 2,
    adapter = "xyz.block.ftl.v1.schema.Float#ADAPTER",
    oneofName = "value",
  )
  public val float: Float? = null,
  @field:WireField(
    tag = 3,
    adapter = "xyz.block.ftl.v1.schema.String#ADAPTER",
    oneofName = "value",
  )
  public val string: String? = null,
  @field:WireField(
    tag = 4,
    adapter = "xyz.block.ftl.v1.schema.Bool#ADAPTER",
    oneofName = "value",
  )
  public val bool: Bool? = null,
  @field:WireField(
    tag = 5,
    adapter = "xyz.block.ftl.v1.schema.Time#ADAPTER",
    oneofName = "value",
  )
  public val time: Time? = null,
  @field:WireField(
    tag = 6,
    adapter = "xyz.block.ftl.v1.schema.Array#ADAPTER",
    oneofName = "value",
  )
  public val array: Array? = null,
  @field:WireField(
    tag = 7,
    adapter = "xyz.block.ftl.v1.schema.Map#ADAPTER",
    oneofName = "value",
  )
  public val map: Map? = null,
  @field:WireField(
    tag = 8,
    adapter = "xyz.block.ftl.v1.schema.VerbRef#ADAPTER",
    oneofName = "value",
  )
  public val verbRef: VerbRef? = null,
  @field:WireField(
    tag = 9,
    adapter = "xyz.block.ftl.v1.schema.DataRef#ADAPTER",
    oneofName = "value",
  )
  public val dataRef: DataRef? = null,
  unknownFields: ByteString = ByteString.EMPTY,
) : Message<Type, Nothing>(ADAPTER, unknownFields) {
  init {
    require(countNonNull(int, float, string, bool, time, array, map, verbRef, dataRef) <= 1) {
      "At most one of int, float, string, bool, time, array, map, verbRef, dataRef may be non-null"
    }
  }

  @Deprecated(
    message = "Shouldn't be used in Kotlin",
    level = DeprecationLevel.HIDDEN,
  )
  public override fun newBuilder(): Nothing = throw
      AssertionError("Builders are deprecated and only available in a javaInterop build; see https://square.github.io/wire/wire_compiler/#kotlin")

  public override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is Type) return false
    if (unknownFields != other.unknownFields) return false
    if (int != other.int) return false
    if (float != other.float) return false
    if (string != other.string) return false
    if (bool != other.bool) return false
    if (time != other.time) return false
    if (array != other.array) return false
    if (map != other.map) return false
    if (verbRef != other.verbRef) return false
    if (dataRef != other.dataRef) return false
    return true
  }

  public override fun hashCode(): kotlin.Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + (int?.hashCode() ?: 0)
      result = result * 37 + (float?.hashCode() ?: 0)
      result = result * 37 + (string?.hashCode() ?: 0)
      result = result * 37 + (bool?.hashCode() ?: 0)
      result = result * 37 + (time?.hashCode() ?: 0)
      result = result * 37 + (array?.hashCode() ?: 0)
      result = result * 37 + (map?.hashCode() ?: 0)
      result = result * 37 + (verbRef?.hashCode() ?: 0)
      result = result * 37 + (dataRef?.hashCode() ?: 0)
      super.hashCode = result
    }
    return result
  }

  public override fun toString(): kotlin.String {
    val result = mutableListOf<kotlin.String>()
    if (int != null) result += """int=$int"""
    if (float != null) result += """float=$float"""
    if (string != null) result += """string=$string"""
    if (bool != null) result += """bool=$bool"""
    if (time != null) result += """time=$time"""
    if (array != null) result += """array=$array"""
    if (map != null) result += """map=$map"""
    if (verbRef != null) result += """verbRef=$verbRef"""
    if (dataRef != null) result += """dataRef=$dataRef"""
    return result.joinToString(prefix = "Type{", separator = ", ", postfix = "}")
  }

  public fun copy(
    int: Int? = this.int,
    float: Float? = this.float,
    string: String? = this.string,
    bool: Bool? = this.bool,
    time: Time? = this.time,
    array: Array? = this.array,
    map: Map? = this.map,
    verbRef: VerbRef? = this.verbRef,
    dataRef: DataRef? = this.dataRef,
    unknownFields: ByteString = this.unknownFields,
  ): Type = Type(int, float, string, bool, time, array, map, verbRef, dataRef, unknownFields)

  public companion object {
    @JvmField
    public val ADAPTER: ProtoAdapter<Type> = object : ProtoAdapter<Type>(
      FieldEncoding.LENGTH_DELIMITED, 
      Type::class, 
      "type.googleapis.com/xyz.block.ftl.v1.schema.Type", 
      PROTO_3, 
      null, 
      "xyz/block/ftl/v1/schema/schema.proto"
    ) {
      public override fun encodedSize(`value`: Type): kotlin.Int {
        var size = value.unknownFields.size
        size += Int.ADAPTER.encodedSizeWithTag(1, value.int)
        size += Float.ADAPTER.encodedSizeWithTag(2, value.float)
        size += String.ADAPTER.encodedSizeWithTag(3, value.string)
        size += Bool.ADAPTER.encodedSizeWithTag(4, value.bool)
        size += Time.ADAPTER.encodedSizeWithTag(5, value.time)
        size += Array.ADAPTER.encodedSizeWithTag(6, value.array)
        size += Map.ADAPTER.encodedSizeWithTag(7, value.map)
        size += VerbRef.ADAPTER.encodedSizeWithTag(8, value.verbRef)
        size += DataRef.ADAPTER.encodedSizeWithTag(9, value.dataRef)
        return size
      }

      public override fun encode(writer: ProtoWriter, `value`: Type): Unit {
        Int.ADAPTER.encodeWithTag(writer, 1, value.int)
        Float.ADAPTER.encodeWithTag(writer, 2, value.float)
        String.ADAPTER.encodeWithTag(writer, 3, value.string)
        Bool.ADAPTER.encodeWithTag(writer, 4, value.bool)
        Time.ADAPTER.encodeWithTag(writer, 5, value.time)
        Array.ADAPTER.encodeWithTag(writer, 6, value.array)
        Map.ADAPTER.encodeWithTag(writer, 7, value.map)
        VerbRef.ADAPTER.encodeWithTag(writer, 8, value.verbRef)
        DataRef.ADAPTER.encodeWithTag(writer, 9, value.dataRef)
        writer.writeBytes(value.unknownFields)
      }

      public override fun encode(writer: ReverseProtoWriter, `value`: Type): Unit {
        writer.writeBytes(value.unknownFields)
        DataRef.ADAPTER.encodeWithTag(writer, 9, value.dataRef)
        VerbRef.ADAPTER.encodeWithTag(writer, 8, value.verbRef)
        Map.ADAPTER.encodeWithTag(writer, 7, value.map)
        Array.ADAPTER.encodeWithTag(writer, 6, value.array)
        Time.ADAPTER.encodeWithTag(writer, 5, value.time)
        Bool.ADAPTER.encodeWithTag(writer, 4, value.bool)
        String.ADAPTER.encodeWithTag(writer, 3, value.string)
        Float.ADAPTER.encodeWithTag(writer, 2, value.float)
        Int.ADAPTER.encodeWithTag(writer, 1, value.int)
      }

      public override fun decode(reader: ProtoReader): Type {
        var int: Int? = null
        var float: Float? = null
        var string: String? = null
        var bool: Bool? = null
        var time: Time? = null
        var array: Array? = null
        var map: Map? = null
        var verbRef: VerbRef? = null
        var dataRef: DataRef? = null
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> int = Int.ADAPTER.decode(reader)
            2 -> float = Float.ADAPTER.decode(reader)
            3 -> string = String.ADAPTER.decode(reader)
            4 -> bool = Bool.ADAPTER.decode(reader)
            5 -> time = Time.ADAPTER.decode(reader)
            6 -> array = Array.ADAPTER.decode(reader)
            7 -> map = Map.ADAPTER.decode(reader)
            8 -> verbRef = VerbRef.ADAPTER.decode(reader)
            9 -> dataRef = DataRef.ADAPTER.decode(reader)
            else -> reader.readUnknownField(tag)
          }
        }
        return Type(
          int = int,
          float = float,
          string = string,
          bool = bool,
          time = time,
          array = array,
          map = map,
          verbRef = verbRef,
          dataRef = dataRef,
          unknownFields = unknownFields
        )
      }

      public override fun redact(`value`: Type): Type = value.copy(
        int = value.int?.let(Int.ADAPTER::redact),
        float = value.float?.let(Float.ADAPTER::redact),
        string = value.string?.let(String.ADAPTER::redact),
        bool = value.bool?.let(Bool.ADAPTER::redact),
        time = value.time?.let(Time.ADAPTER::redact),
        array = value.array?.let(Array.ADAPTER::redact),
        map = value.map?.let(Map.ADAPTER::redact),
        verbRef = value.verbRef?.let(VerbRef.ADAPTER::redact),
        dataRef = value.dataRef?.let(DataRef.ADAPTER::redact),
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L
  }
}
