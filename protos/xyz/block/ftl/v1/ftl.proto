syntax = "proto3";

package xyz.block.ftl.v1;

import "opentelemetry/proto/metrics/v1/metrics.proto";
import "xyz/block/ftl/v1/schema/schema.proto";

option go_package = "github.com/TBD54566975/ftl/protos/xyz/block/ftl/v1;ftlv1";
option java_multiple_files = true;

message PingRequest {}
message PingResponse {
  // If present, the service is not ready to accept requests and this is the
  // reason.
  optional string not_ready = 1;
}

message Metadata {
  message Pair {
    string key = 1;
    string value = 2;
  }
  repeated Pair values = 1;
}

message CallRequest {
  Metadata metadata = 1;

  schema.VerbRef verb = 2;
  bytes body = 3;
}
message CallResponse {
  message Error {
    string message = 1;
    // TODO: Richer error type.
  }

  oneof response {
    bytes body = 1;
    Error error = 2;
  }
}

// VerbService is a common interface shared by multiple services for calling Verbs.
service VerbService {
  // Ping service for readiness.
  rpc Ping(PingRequest) returns (PingResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Issue a synchronous call to a Verb.
  rpc Call(CallRequest) returns (CallResponse);
}

message PullSchemaRequest {}
message PullSchemaResponse {
  schema.Module schema = 1;
  // If true, there are more schema changes immediately following this one.
  // If false, there still may be more schema changes in the future.
  bool more = 2;
}

message GetArtefactDiffsRequest {
  repeated string client_digests = 1;
}
message GetArtefactDiffsResponse {
  repeated string missing_digests = 1;
  // Artefacts that the client already has, and their path+executable status.
  repeated DeploymentArtefact client_artefacts = 2;
}

message UploadArtefactRequest {
  bytes content = 1;
}
message UploadArtefactResponse {
  bytes digest = 2;
}

message DeploymentArtefact {
  string digest = 1;
  string path = 2;
  bool executable = 3;
}

message CreateDeploymentRequest {
  schema.Module schema = 1;
  repeated DeploymentArtefact artefacts = 2;
}
message CreateDeploymentResponse {
  string deployment_key = 1;
}

message GetDeploymentArtefactsRequest {
  string deployment_key = 1;
  repeated DeploymentArtefact have_artefacts = 2;
}
message GetDeploymentArtefactsResponse {
  DeploymentArtefact artefact = 1;
  bytes chunk = 2;
}

message GetDeploymentRequest {
  string deployment_key = 1;
}
message GetDeploymentResponse {
  schema.Module schema = 1;
  repeated DeploymentArtefact artefacts = 2;
}

enum RunnerState {
  // The Runner is waiting for a deployment.
  IDLE = 0;
  // The Runner and Control Plane have agreed that the Runner is reserved.
  RESERVED = 1;
  // The Runner is assigned to a deployment.
  ASSIGNED = 2;
}

message RegisterRunnerRequest {
  // UUID representing the runner instance.
  string key = 1;
  // Language the runner supports.
  string language = 2;
  string endpoint = 3;
  optional string deployment = 4;
  RunnerState state = 5;
  // If present, the reason the Runner is transitioning from ASSIGNED to IDLE.
  optional string error = 6;
}
message RegisterRunnerResponse {}

message DeployRequest {
  string deployment_key = 1;
  int32 min_replicas = 2;
}
message DeployResponse {}

message StreamDeploymentLogsRequest {
  string deployment_key = 1;
  int64 time_stamp = 2;
  int32 log_level = 3;
  string scope = 4;
  string message = 5;
  optional string error = 6;
}
message StreamDeploymentLogsResponse {}

service ControlPlaneService {
  // Ping service for readiness.
  rpc Ping(PingRequest) returns (PingResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Get list of artefacts that differ between the server and client.
  rpc GetArtefactDiffs(GetArtefactDiffsRequest) returns (GetArtefactDiffsResponse);

  // Upload an artefact to the server.
  rpc UploadArtefact(UploadArtefactRequest) returns (UploadArtefactResponse);

  // Create a deployment.
  rpc CreateDeployment(CreateDeploymentRequest) returns (CreateDeploymentResponse);

  // Get the schema and artefact metadata for a deployment.
  rpc GetDeployment(GetDeploymentRequest) returns (GetDeploymentResponse);

  // Stream deployment artefacts from the server.
  //
  // Each artefact is streamed one after the other as a sequence of max 1MB
  // chunks.
  rpc GetDeploymentArtefacts(GetDeploymentArtefactsRequest) returns (stream GetDeploymentArtefactsResponse);

  // Register a Runner with the ControlPlane.
  //
  // Each runner MUST stream a RegisterRunnerRequest to the ControlPlaneService
  // every 10 seconds to maintain its heartbeat.
  rpc RegisterRunner(stream RegisterRunnerRequest) returns (RegisterRunnerResponse);

  // Starts a deployment.
  rpc Deploy(DeployRequest) returns (DeployResponse);

  // Stream logs from a deployment
  rpc StreamDeploymentLogs(stream StreamDeploymentLogsRequest) returns (StreamDeploymentLogsResponse);

  // Pull schema changes from the Control Plane.
  // TODO(aat): Implement this.
  //  rpc PullSchema(PullSchemaRequest) returns (stream PullSchemaResponse);
}

message DeployToRunnerRequest {
  string deployment_key = 1;
}
message DeployToRunnerResponse {}

// RunnerService is the service that executes Deployments.
//
// The ControlPlane will scale the Runner horizontally as required. The Runner will
// register itself automatically with the ControlPlaneService, which will then
// assign modules to it.
service RunnerService {
  rpc Ping(PingRequest) returns (PingResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Initiate a deployment on this Runner.
  rpc DeployToRunner(DeployToRunnerRequest) returns (DeployToRunnerResponse);
}

enum MetricType {
  COUNTER = 0;
  GAUGE = 1;
  HISTOGRAM = 2;
}

message SendMetricRequest {
  string runner_key = 1;
  repeated opentelemetry.proto.metrics.v1.ScopeMetrics scope_metrics = 2;
}

message SendMetricResponse {}

service ObservabilityService {
  // Ping service for readiness.
  rpc Ping(PingRequest) returns (PingResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  rpc SendMetric(SendMetricRequest) returns (SendMetricResponse);
}
